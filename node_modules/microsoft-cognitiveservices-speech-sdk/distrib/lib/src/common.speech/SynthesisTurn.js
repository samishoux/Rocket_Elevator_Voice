"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
var Exports_1 = require("../common/Exports");
var AudioOutputStream_1 = require("../sdk/Audio/AudioOutputStream");
var SynthesisAdapterBase_1 = require("./SynthesisAdapterBase");
var SynthesisEvents_1 = require("./SynthesisEvents");
var SynthesisTurn = /** @class */ (function () {
    function SynthesisTurn() {
        var _this = this;
        this.privIsDisposed = false;
        this.privIsSynthesizing = false;
        this.privIsSynthesisEnded = false;
        this.privBytesReceived = 0;
        this.privTextOffset = 0;
        this.privNextSearchTextIndex = 0;
        this.onPreConnectionStart = function (authFetchEventId, connectionId) {
            _this.privAuthFetchEventId = authFetchEventId;
            _this.onEvent(new SynthesisEvents_1.ConnectingToSynthesisServiceEvent(_this.privRequestId, _this.privAuthFetchEventId));
        };
        this.onAuthCompleted = function (isError, error) {
            if (isError) {
                _this.onComplete();
            }
        };
        this.onConnectionEstablishCompleted = function (statusCode, reason) {
            if (statusCode === 200) {
                _this.onEvent(new SynthesisEvents_1.SynthesisStartedEvent(_this.requestId, _this.privAuthFetchEventId));
                _this.privBytesReceived = 0;
                return;
            }
            else if (statusCode === 403) {
                _this.onComplete();
            }
        };
        this.onServiceResponseMessage = function (responseJson) {
            var response = JSON.parse(responseJson);
            _this.streamId = response.audio.streamId;
        };
        this.onServiceTurnEndResponse = function () {
            _this.privTurnDeferral.resolve(true);
            _this.onComplete();
        };
        this.onServiceTurnStartResponse = function () {
            if (_this.privTurnDeferral.state() === Exports_1.PromiseState.None) {
                // What? How are we starting a turn with another not done?
                _this.privTurnDeferral.reject("Another turn started before current completed.");
            }
            _this.privTurnDeferral = new Exports_1.Deferred();
        };
        this.dispose = function (error) {
            if (!_this.privIsDisposed) {
                // we should have completed by now. If we did not its an unknown error.
                _this.privIsDisposed = true;
            }
        };
        this.onEvent = function (event) {
            Exports_1.Events.instance.onEvent(event);
        };
        this.onComplete = function () {
            if (_this.privIsSynthesizing) {
                _this.privIsSynthesizing = false;
                _this.privIsSynthesisEnded = true;
                _this.privAudioOutputStream.close();
                if (_this.privTurnAudioDestination !== undefined) {
                    _this.privTurnAudioDestination.close();
                    _this.privTurnAudioDestination = undefined;
                }
            }
        };
        this.privRequestId = Exports_1.createNoDashGuid();
        this.privTurnDeferral = new Exports_1.Deferred();
        // We're not in a turn, so resolve.
        this.privTurnDeferral.resolve(true);
    }
    Object.defineProperty(SynthesisTurn.prototype, "requestId", {
        get: function () {
            return this.privRequestId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SynthesisTurn.prototype, "streamId", {
        get: function () {
            return this.privStreamId;
        },
        set: function (value) {
            this.privStreamId = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SynthesisTurn.prototype, "audioOutputFormat", {
        get: function () {
            return this.privAudioOutputFormat;
        },
        set: function (format) {
            this.privAudioOutputFormat = format;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SynthesisTurn.prototype, "turnCompletionPromise", {
        get: function () {
            return this.privTurnDeferral.promise();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SynthesisTurn.prototype, "isSynthesisEnded", {
        get: function () {
            return this.privIsSynthesisEnded;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SynthesisTurn.prototype, "isSynthesizing", {
        get: function () {
            return this.privIsSynthesizing;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SynthesisTurn.prototype, "currentTextOffset", {
        get: function () {
            return this.privTextOffset;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SynthesisTurn.prototype, "bytesReceived", {
        // The number of bytes received for current turn
        get: function () {
            return this.privBytesReceived;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SynthesisTurn.prototype, "allReceivedAudio", {
        get: function () {
            if (!!this.privReceivedAudio) {
                return this.privReceivedAudio;
            }
            if (!this.privIsSynthesisEnded) {
                return null;
            }
            this.readAllAudioFromStream();
            return this.allReceivedAudio;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SynthesisTurn.prototype, "allReceivedAudioWithHeader", {
        get: function () {
            if (!!this.privReceivedAudioWithHeader) {
                return this.privReceivedAudioWithHeader;
            }
            if (!this.privIsSynthesisEnded) {
                return null;
            }
            if (this.audioOutputFormat.hasHeader) {
                this.privReceivedAudioWithHeader = SynthesisAdapterBase_1.SynthesisAdapterBase.addHeader(this.allReceivedAudio, this.audioOutputFormat);
                return this.allReceivedAudioWithHeader;
            }
            else {
                return this.allReceivedAudio;
            }
        },
        enumerable: true,
        configurable: true
    });
    SynthesisTurn.prototype.startNewSynthesis = function (requestId, rawText, isSSML, audioDestination) {
        this.privIsSynthesisEnded = false;
        this.privIsSynthesizing = true;
        this.privRequestId = requestId;
        this.privRawText = rawText;
        this.privIsSSML = isSSML;
        this.privAudioOutputStream = new AudioOutputStream_1.PullAudioOutputStreamImpl();
        this.privAudioOutputStream.format = this.privAudioOutputFormat;
        this.privReceivedAudio = null;
        this.privReceivedAudioWithHeader = null;
        this.privBytesReceived = 0;
        this.privTextOffset = 0;
        this.privNextSearchTextIndex = 0;
        if (audioDestination !== undefined) {
            this.privTurnAudioDestination = audioDestination;
            this.privTurnAudioDestination.format = this.privAudioOutputFormat;
        }
        this.onEvent(new SynthesisEvents_1.SynthesisTriggeredEvent(this.requestId, undefined, audioDestination === undefined ? undefined : audioDestination.id()));
    };
    SynthesisTurn.prototype.onAudioChunkReceived = function (data) {
        if (this.isSynthesizing) {
            this.privAudioOutputStream.write(data);
            this.privBytesReceived += data.byteLength;
            if (this.privTurnAudioDestination !== undefined) {
                this.privTurnAudioDestination.write(data);
            }
        }
    };
    SynthesisTurn.prototype.onWordBoundaryEvent = function (text) {
        this.updateTextOffset(text);
    };
    SynthesisTurn.prototype.onStopSynthesizing = function () {
        this.onComplete();
    };
    SynthesisTurn.prototype.updateTextOffset = function (text) {
        if (this.privTextOffset >= 0) {
            this.privTextOffset = this.privRawText.indexOf(text, this.privNextSearchTextIndex);
            if (this.privTextOffset >= 0) {
                this.privNextSearchTextIndex = this.privTextOffset + text.length;
            }
            if (this.privIsSSML) {
                if (this.privRawText.indexOf("<", this.privTextOffset + 1) > this.privRawText.indexOf(">", this.privTextOffset + 1)) {
                    this.updateTextOffset(text);
                }
            }
        }
    };
    SynthesisTurn.prototype.readAllAudioFromStream = function () {
        if (this.privIsSynthesisEnded) {
            this.privReceivedAudio = new ArrayBuffer(this.bytesReceived);
            try {
                this.privAudioOutputStream.read(this.privReceivedAudio);
            }
            catch (e) {
                this.privReceivedAudio = new ArrayBuffer(0);
            }
        }
    };
    return SynthesisTurn;
}());
exports.SynthesisTurn = SynthesisTurn;

//# sourceMappingURL=SynthesisTurn.js.map
