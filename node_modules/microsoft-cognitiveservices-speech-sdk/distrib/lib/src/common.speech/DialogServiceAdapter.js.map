{"version":3,"sources":["src/common.speech/DialogServiceAdapter.ts"],"names":[],"mappings":"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","file":"DialogServiceAdapter.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { ReplayableAudioNode } from \"../common.browser/Exports\";\r\nimport {\r\n    ConnectionEvent,\r\n    ConnectionMessage,\r\n    ConnectionOpenResponse,\r\n    ConnectionState,\r\n    createGuid,\r\n    createNoDashGuid,\r\n    Deferred,\r\n    IAudioSource,\r\n    IAudioStreamNode,\r\n    IConnection,\r\n    IStreamChunk,\r\n    MessageType,\r\n    Promise,\r\n    PromiseHelper,\r\n    PromiseResult,\r\n    ServiceEvent,\r\n} from \"../common/Exports\";\r\nimport { AudioOutputFormatImpl } from \"../sdk/Audio/AudioOutputFormat\";\r\nimport { PullAudioOutputStreamImpl } from \"../sdk/Audio/AudioOutputStream\";\r\nimport { AudioStreamFormatImpl } from \"../sdk/Audio/AudioStreamFormat\";\r\nimport {\r\n    ActivityReceivedEventArgs,\r\n    AudioOutputStream,\r\n    CancellationErrorCode,\r\n    CancellationReason,\r\n    DialogServiceConnector,\r\n    PropertyCollection,\r\n    PropertyId,\r\n    PullAudioOutputStream,\r\n    RecognitionEventArgs,\r\n    ResultReason,\r\n    SessionEventArgs,\r\n    SpeechRecognitionCanceledEventArgs,\r\n    SpeechRecognitionEventArgs,\r\n    SpeechRecognitionResult,\r\n    SpeechSynthesisOutputFormat,\r\n} from \"../sdk/Exports\";\r\nimport { DialogServiceTurnStateManager } from \"./DialogServiceTurnStateManager\";\r\nimport {\r\n    AgentConfig,\r\n    CancellationErrorCodePropertyName,\r\n    EnumTranslation,\r\n    ISpeechConfigAudioDevice,\r\n    RecognitionStatus,\r\n    RequestSession,\r\n    ServiceRecognizerBase,\r\n    SimpleSpeechPhrase,\r\n    SpeechDetected,\r\n    SpeechHypothesis,\r\n} from \"./Exports\";\r\nimport { AuthInfo, IAuthentication } from \"./IAuthentication\";\r\nimport { IConnectionFactory } from \"./IConnectionFactory\";\r\nimport { RecognitionMode, RecognizerConfig } from \"./RecognizerConfig\";\r\nimport { ActivityPayloadResponse } from \"./ServiceMessages/ActivityResponsePayload\";\r\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal\";\r\n\r\nexport class DialogServiceAdapter extends ServiceRecognizerBase {\r\n    private privDialogServiceConnector: DialogServiceConnector;\r\n    private privDialogConnectionFactory: IConnectionFactory;\r\n    private privDialogAuthFetchEventId: string;\r\n    private privDialogIsDisposed: boolean;\r\n    private privDialogAuthentication: IAuthentication;\r\n    private privDialogAudioSource: IAudioSource;\r\n    private privDialogRequestSession: RequestSession;\r\n\r\n    // A promise for a configured connection.\r\n    // Do not consume directly, call fetchDialogConnection instead.\r\n    private privConnectionConfigPromise: Promise<IConnection>;\r\n\r\n    // A promise for a connection, but one that has not had the speech context sent yet.\r\n    // Do not consume directly, call fetchDialogConnection instead.\r\n    private privDialogConnectionPromise: Promise<IConnection>;\r\n\r\n    private privConnectionLoop: Promise<IConnection>;\r\n    private terminateMessageLoop: boolean;\r\n    private agentConfigSent: boolean;\r\n    private privLastResult: SpeechRecognitionResult;\r\n\r\n    // Turns are of two kinds:\r\n    // 1: SR turns, end when the SR result is returned and then turn end.\r\n    // 2: Service turns where an activity is sent by the service along with the audio.\r\n    private privTurnStateManager: DialogServiceTurnStateManager;\r\n\r\n    public constructor(\r\n        authentication: IAuthentication,\r\n        connectionFactory: IConnectionFactory,\r\n        audioSource: IAudioSource,\r\n        recognizerConfig: RecognizerConfig,\r\n        dialogServiceConnector: DialogServiceConnector) {\r\n\r\n        super(authentication, connectionFactory, audioSource, recognizerConfig, dialogServiceConnector);\r\n\r\n        this.privDialogServiceConnector = dialogServiceConnector;\r\n        this.privDialogAuthentication = authentication;\r\n        this.receiveMessageOverride = this.receiveDialogMessageOverride;\r\n        this.privTurnStateManager = new DialogServiceTurnStateManager();\r\n        this.recognizeOverride = this.listenOnce;\r\n        this.connectImplOverride = this.dialogConnectImpl;\r\n        this.configConnectionOverride = this.configConnection;\r\n        this.fetchConnectionOverride = this.fetchDialogConnection;\r\n        this.disconnectOverride = this.privDisconnect;\r\n        this.privDialogAudioSource = audioSource;\r\n        this.privDialogRequestSession = new RequestSession(audioSource.id());\r\n        this.privDialogConnectionFactory = connectionFactory;\r\n        this.privDialogIsDisposed = false;\r\n        this.agentConfigSent = false;\r\n        this.privLastResult = null;\r\n    }\r\n\r\n    public isDisposed(): boolean {\r\n        return this.privDialogIsDisposed;\r\n    }\r\n\r\n    public dispose(reason?: string): void {\r\n        this.privDialogIsDisposed = true;\r\n        if (this.privConnectionConfigPromise) {\r\n            this.privConnectionConfigPromise.onSuccessContinueWith((connection: IConnection) => {\r\n                connection.dispose(reason);\r\n            });\r\n        }\r\n    }\r\n\r\n    public sendMessage = (message: string): void => {\r\n        const interactionGuid: string = createGuid();\r\n        const requestId: string = createNoDashGuid();\r\n\r\n        const agentMessage: any = {\r\n            context: {\r\n                interactionId: interactionGuid\r\n            },\r\n            messagePayload: JSON.parse(message),\r\n            version: 0.5\r\n        };\r\n\r\n        const agentMessageJson = JSON.stringify(agentMessage);\r\n\r\n        this.fetchDialogConnection().onSuccessContinueWith((connection: IConnection) => {\r\n            connection.send(new SpeechConnectionMessage(\r\n                MessageType.Text,\r\n                \"agent\",\r\n                requestId,\r\n                \"application/json\",\r\n                agentMessageJson));\r\n        });\r\n    }\r\n\r\n    protected privDisconnect(): void {\r\n        this.cancelRecognition(this.privDialogRequestSession.sessionId,\r\n            this.privDialogRequestSession.requestId,\r\n            CancellationReason.Error,\r\n            CancellationErrorCode.NoError,\r\n            \"Disconnecting\");\r\n\r\n        this.terminateMessageLoop = true;\r\n        this.agentConfigSent = false;\r\n        if (this.privDialogConnectionPromise.result().isCompleted) {\r\n            if (!this.privDialogConnectionPromise.result().isError) {\r\n                this.privDialogConnectionPromise.result().result.dispose();\r\n                this.privDialogConnectionPromise = null;\r\n            }\r\n        } else {\r\n            this.privDialogConnectionPromise.onSuccessContinueWith((connection: IConnection) => {\r\n                connection.dispose();\r\n            });\r\n        }\r\n    }\r\n\r\n    protected processTypeSpecificMessages(connectionMessage: SpeechConnectionMessage): boolean {\r\n\r\n        const resultProps: PropertyCollection = new PropertyCollection();\r\n        if (connectionMessage.messageType === MessageType.Text) {\r\n            resultProps.setProperty(PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);\r\n        }\r\n\r\n        let result: SpeechRecognitionResult;\r\n        let processed: boolean;\r\n\r\n        switch (connectionMessage.path.toLowerCase()) {\r\n            case \"speech.phrase\":\r\n                const speechPhrase: SimpleSpeechPhrase = SimpleSpeechPhrase.fromJSON(connectionMessage.textBody);\r\n\r\n                this.privDialogRequestSession.onPhraseRecognized(this.privDialogRequestSession.currentTurnAudioOffset + speechPhrase.Offset + speechPhrase.Duration);\r\n\r\n                if (speechPhrase.RecognitionStatus === RecognitionStatus.Success) {\r\n                    const args: SpeechRecognitionEventArgs = this.fireEventForResult(speechPhrase, resultProps);\r\n                    this.privLastResult = args.result;\r\n\r\n                    if (!!this.privDialogServiceConnector.recognized) {\r\n                        try {\r\n                            this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, args);\r\n                            /* tslint:disable:no-empty */\r\n                        } catch (error) {\r\n                            // Not going to let errors in the event handler\r\n                            // trip things up.\r\n                        }\r\n                    }\r\n                }\r\n                processed = true;\r\n                break;\r\n            case \"speech.hypothesis\":\r\n                const hypothesis: SpeechHypothesis = SpeechHypothesis.fromJSON(connectionMessage.textBody);\r\n                const offset: number = hypothesis.Offset + this.privDialogRequestSession.currentTurnAudioOffset;\r\n\r\n                result = new SpeechRecognitionResult(\r\n                    this.privDialogRequestSession.requestId,\r\n                    ResultReason.RecognizingSpeech,\r\n                    hypothesis.Text,\r\n                    hypothesis.Duration,\r\n                    offset,\r\n                    hypothesis.Language,\r\n                    hypothesis.LanguageDetectionConfidence,\r\n                    undefined,\r\n                    connectionMessage.textBody,\r\n                    resultProps);\r\n\r\n                this.privDialogRequestSession.onHypothesis(offset);\r\n\r\n                const ev = new SpeechRecognitionEventArgs(result, hypothesis.Duration, this.privDialogRequestSession.sessionId);\r\n\r\n                if (!!this.privDialogServiceConnector.recognizing) {\r\n                    try {\r\n                        this.privDialogServiceConnector.recognizing(this.privDialogServiceConnector, ev);\r\n                        /* tslint:disable:no-empty */\r\n                    } catch (error) {\r\n                        // Not going to let errors in the event handler\r\n                        // trip things up.\r\n                    }\r\n                }\r\n                processed = true;\r\n                break;\r\n\r\n            case \"audio\":\r\n                {\r\n                    const audioRequestId = connectionMessage.requestId.toUpperCase();\r\n                    const turn = this.privTurnStateManager.GetTurn(audioRequestId);\r\n                    try {\r\n                        // Empty binary message signals end of stream.\r\n                        if (!connectionMessage.binaryBody) {\r\n                            turn.endAudioStream();\r\n                        } else {\r\n                            turn.audioStream.write(connectionMessage.binaryBody);\r\n                        }\r\n                    } catch (error) {\r\n                        // Not going to let errors in the event handler\r\n                        // trip things up.\r\n                    }\r\n                }\r\n                processed = true;\r\n                break;\r\n\r\n            case \"response\":\r\n                {\r\n                    const responseRequestId = connectionMessage.requestId.toUpperCase();\r\n                    const activityPayload: ActivityPayloadResponse = ActivityPayloadResponse.fromJSON(connectionMessage.textBody);\r\n                    const turn = this.privTurnStateManager.GetTurn(responseRequestId);\r\n\r\n                    // update the conversation Id\r\n                    if (activityPayload.conversationId) {\r\n                        const updateAgentConfig = this.agentConfig.get();\r\n                        updateAgentConfig.botInfo.conversationId = activityPayload.conversationId;\r\n                        this.agentConfig.set(updateAgentConfig);\r\n                    }\r\n\r\n                    const pullAudioOutputStream: PullAudioOutputStreamImpl = turn.processActivityPayload(activityPayload, (SpeechSynthesisOutputFormat as any)[this.privDialogServiceConnector.properties.getProperty(PropertyId.SpeechServiceConnection_SynthOutputFormat, undefined)]);\r\n                    const activity = new ActivityReceivedEventArgs(activityPayload.messagePayload, pullAudioOutputStream);\r\n                    if (!!this.privDialogServiceConnector.activityReceived) {\r\n                        try {\r\n                            this.privDialogServiceConnector.activityReceived(this.privDialogServiceConnector, activity);\r\n                            /* tslint:disable:no-empty */\r\n                        } catch (error) {\r\n                            // Not going to let errors in the event handler\r\n                            // trip things up.\r\n                        }\r\n                    }\r\n                }\r\n                processed = true;\r\n                break;\r\n\r\n            default:\r\n                break;\r\n        }\r\n        return processed;\r\n    }\r\n\r\n    // Cancels recognition.\r\n    protected cancelRecognition(\r\n        sessionId: string,\r\n        requestId: string,\r\n        cancellationReason: CancellationReason,\r\n        errorCode: CancellationErrorCode,\r\n        error: string): void {\r\n\r\n        this.terminateMessageLoop = true;\r\n\r\n        if (!!this.privDialogRequestSession.isRecognizing) {\r\n            this.privDialogRequestSession.onStopRecognizing();\r\n        }\r\n\r\n        if (!!this.privDialogServiceConnector.canceled) {\r\n            const properties: PropertyCollection = new PropertyCollection();\r\n            properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\r\n\r\n            const cancelEvent: SpeechRecognitionCanceledEventArgs = new SpeechRecognitionCanceledEventArgs(\r\n                cancellationReason,\r\n                error,\r\n                errorCode,\r\n                undefined,\r\n                sessionId);\r\n\r\n            try {\r\n                this.privDialogServiceConnector.canceled(this.privDialogServiceConnector, cancelEvent);\r\n                /* tslint:disable:no-empty */\r\n            } catch { }\r\n\r\n            if (!!this.privSuccessCallback) {\r\n                const result: SpeechRecognitionResult = new SpeechRecognitionResult(\r\n                    undefined, // ResultId\r\n                    ResultReason.Canceled,\r\n                    undefined, // Text\r\n                    undefined, // Druation\r\n                    undefined, // Offset\r\n                    undefined, // Language\r\n                    undefined, // Language Detection Confidence\r\n                    error,\r\n                    undefined, // Json\r\n                    properties);\r\n                try {\r\n                    this.privSuccessCallback(result);\r\n                    this.privSuccessCallback = undefined;\r\n                    /* tslint:disable:no-empty */\r\n                } catch { }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected listenOnce = (\r\n        recoMode: RecognitionMode,\r\n        successCallback: (e: SpeechRecognitionResult) => void,\r\n        errorCallback: (e: string) => void\r\n    ): Promise<boolean> => {\r\n        this.privRecognizerConfig.recognitionMode = recoMode;\r\n\r\n        this.privSuccessCallback = successCallback;\r\n        this.privErrorCallback = errorCallback;\r\n\r\n        this.privDialogRequestSession.startNewRecognition();\r\n        this.privDialogRequestSession.listenForServiceTelemetry(this.privDialogAudioSource.events);\r\n\r\n        // Start the connection to the service. The promise this will create is stored and will be used by configureConnection().\r\n        this.dialogConnectImpl();\r\n\r\n        this.sendPreAudioMessages();\r\n\r\n        return this.privDialogAudioSource\r\n            .attach(this.privDialogRequestSession.audioNodeId)\r\n            .continueWithPromise<boolean>((result: PromiseResult<IAudioStreamNode>) => {\r\n                let audioNode: ReplayableAudioNode;\r\n\r\n                if (result.isError) {\r\n                    this.cancelRecognition(this.privDialogRequestSession.sessionId, this.privDialogRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.ConnectionFailure, result.error);\r\n                    return PromiseHelper.fromError<boolean>(result.error);\r\n                }\r\n\r\n                return this.privDialogAudioSource.format.onSuccessContinueWithPromise<boolean>((format: AudioStreamFormatImpl) => {\r\n                    audioNode = new ReplayableAudioNode(result.result, format.avgBytesPerSec);\r\n                    this.privDialogRequestSession.onAudioSourceAttachCompleted(audioNode, false);\r\n\r\n                    return this.privDialogAudioSource.deviceInfo.onSuccessContinueWithPromise<boolean>((deviceInfo: ISpeechConfigAudioDevice): Promise<boolean> => {\r\n                        this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: deviceInfo };\r\n\r\n                        return this.configConnection()\r\n                            .continueWithPromise<boolean>((result: PromiseResult<IConnection>): Promise<boolean> => {\r\n                                if (result.isError) {\r\n                                    this.cancelRecognitionLocal(CancellationReason.Error, CancellationErrorCode.ConnectionFailure, result.error);\r\n                                    return PromiseHelper.fromError(result.error);\r\n                                }\r\n\r\n                                const sessionStartEventArgs: SessionEventArgs = new SessionEventArgs(this.privDialogRequestSession.sessionId);\r\n\r\n                                if (!!this.privRecognizer.sessionStarted) {\r\n                                    this.privRecognizer.sessionStarted(this.privRecognizer, sessionStartEventArgs);\r\n                                }\r\n\r\n                                const audioSendPromise = this.sendAudio(audioNode);\r\n\r\n                                // /* tslint:disable:no-empty */\r\n                                audioSendPromise.on((_: boolean) => { /*add? return true;*/ }, (error: string) => {\r\n                                    this.cancelRecognition(this.privDialogRequestSession.sessionId, this.privDialogRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\r\n                                });\r\n\r\n                                return PromiseHelper.fromResult(true);\r\n                            });\r\n                    });\r\n                });\r\n            });\r\n    }\r\n\r\n    protected sendAudio = (audioStreamNode: IAudioStreamNode): Promise<boolean> => {\r\n        return this.privDialogAudioSource.format.onSuccessContinueWithPromise<boolean>((audioFormat: AudioStreamFormatImpl) => {\r\n            // NOTE: Home-baked promises crash ios safari during the invocation\r\n            // of the error callback chain (looks like the recursion is way too deep, and\r\n            // it blows up the stack). The following construct is a stop-gap that does not\r\n            // bubble the error up the callback chain and hence circumvents this problem.\r\n            // TODO: rewrite with ES6 promises.\r\n            const deferred = new Deferred<boolean>();\r\n\r\n            // The time we last sent data to the service.\r\n            let nextSendTime: number = Date.now();\r\n\r\n            // Max amount to send before we start to throttle\r\n            const fastLaneSizeMs: string = this.privRecognizerConfig.parameters.getProperty(\"SPEECH-TransmitLengthBeforThrottleMs\", \"5000\");\r\n            const maxSendUnthrottledBytes: number = audioFormat.avgBytesPerSec / 1000 * parseInt(fastLaneSizeMs, 10);\r\n            const startRecogNumber: number = this.privDialogRequestSession.recogNumber;\r\n\r\n            const readAndUploadCycle = () => {\r\n\r\n                // If speech is done, stop sending audio.\r\n                if (!this.privDialogIsDisposed &&\r\n                    !this.privDialogRequestSession.isSpeechEnded &&\r\n                    this.privDialogRequestSession.isRecognizing &&\r\n                    this.privDialogRequestSession.recogNumber === startRecogNumber) {\r\n                    this.fetchDialogConnection().on((connection: IConnection) => {\r\n                        audioStreamNode.read().on(\r\n                            (audioStreamChunk: IStreamChunk<ArrayBuffer>) => {\r\n                                // we have a new audio chunk to upload.\r\n                                if (this.privDialogRequestSession.isSpeechEnded) {\r\n                                    // If service already recognized audio end then don't send any more audio\r\n                                    deferred.resolve(true);\r\n                                    return;\r\n                                }\r\n\r\n                                let payload: ArrayBuffer;\r\n                                let sendDelay: number;\r\n\r\n                                if (!audioStreamChunk || audioStreamChunk.isEnd) {\r\n                                    payload = null;\r\n                                    sendDelay = 0;\r\n                                } else {\r\n                                    payload = audioStreamChunk.buffer;\r\n                                    this.privDialogRequestSession.onAudioSent(payload.byteLength);\r\n\r\n                                    if (maxSendUnthrottledBytes >= this.privDialogRequestSession.bytesSent) {\r\n                                        sendDelay = 0;\r\n                                    } else {\r\n                                        sendDelay = Math.max(0, nextSendTime - Date.now());\r\n                                    }\r\n                                }\r\n\r\n                                // Are we ready to send, or need we delay more?\r\n                                setTimeout(() => {\r\n                                    if (payload !== null) {\r\n                                        nextSendTime = Date.now() + (payload.byteLength * 1000 / (audioFormat.avgBytesPerSec * 2));\r\n                                    }\r\n\r\n                                    const uploaded: Promise<boolean> = connection.send(\r\n                                        new SpeechConnectionMessage(\r\n                                            MessageType.Binary, \"audio\", this.privDialogRequestSession.requestId, null, payload));\r\n\r\n                                    if (audioStreamChunk && !audioStreamChunk.isEnd) {\r\n                                        uploaded.continueWith((_: PromiseResult<boolean>) => {\r\n\r\n                                            // Regardless of success or failure, schedule the next upload.\r\n                                            // If the underlying connection was broken, the next cycle will\r\n                                            // get a new connection and re-transmit missing audio automatically.\r\n                                            readAndUploadCycle();\r\n                                        });\r\n                                    } else {\r\n                                        // the audio stream has been closed, no need to schedule next\r\n                                        // read-upload cycle.\r\n                                        this.privDialogRequestSession.onSpeechEnded();\r\n                                        deferred.resolve(true);\r\n                                    }\r\n                                }, sendDelay);\r\n                            },\r\n                            (error: string) => {\r\n                                if (this.privDialogRequestSession.isSpeechEnded) {\r\n                                    // For whatever reason, Reject is used to remove queue subscribers inside\r\n                                    // the Queue.DrainAndDispose invoked from DetachAudioNode down below, which\r\n                                    // means that sometimes things can be rejected in normal circumstances, without\r\n                                    // any errors.\r\n                                    deferred.resolve(true); // TODO: remove the argument, it's is completely meaningless.\r\n                                } else {\r\n                                    // Only reject, if there was a proper error.\r\n                                    deferred.reject(error);\r\n                                }\r\n                            });\r\n                    }, (error: string) => {\r\n                        deferred.reject(error);\r\n                    });\r\n                }\r\n            };\r\n\r\n            readAndUploadCycle();\r\n\r\n            return deferred.promise();\r\n        });\r\n    }\r\n\r\n    protected sendWaveHeader(connection: IConnection): Promise<boolean> {\r\n        return this.audioSource.format.onSuccessContinueWithPromise<boolean>((format: AudioStreamFormatImpl) => {\r\n            return connection.send(new SpeechConnectionMessage(\r\n                MessageType.Binary,\r\n                \"audio\",\r\n                this.privDialogRequestSession.requestId,\r\n                \"audio/x-wav\",\r\n                format.header));\r\n        });\r\n    }\r\n\r\n    // Establishes a websocket connection to the end point.\r\n    private dialogConnectImpl(isUnAuthorized: boolean = false): Promise<IConnection> {\r\n        if (this.privDialogConnectionPromise) {\r\n            if (this.privDialogConnectionPromise.result().isCompleted &&\r\n                (this.privDialogConnectionPromise.result().isError\r\n                    || this.privDialogConnectionPromise.result().result.state() === ConnectionState.Disconnected)) {\r\n                this.agentConfigSent = false;\r\n                this.privDialogConnectionPromise = null;\r\n                this.terminateMessageLoop = true;\r\n                return this.configConnection();\r\n            } else {\r\n                return this.privDialogConnectionPromise;\r\n            }\r\n        }\r\n\r\n        this.privDialogAuthFetchEventId = createNoDashGuid();\r\n\r\n        // keep the connectionId for reconnect events\r\n        if (this.privConnectionId === undefined) {\r\n            this.privConnectionId = createNoDashGuid();\r\n        }\r\n\r\n        this.privDialogRequestSession.onPreConnectionStart(this.privDialogAuthFetchEventId, this.privConnectionId);\r\n\r\n        const authPromise = isUnAuthorized ? this.privDialogAuthentication.fetchOnExpiry(this.privDialogAuthFetchEventId) : this.privDialogAuthentication.fetch(this.privDialogAuthFetchEventId);\r\n\r\n        this.privDialogConnectionPromise = authPromise\r\n            .continueWithPromise((result: PromiseResult<AuthInfo>) => {\r\n                if (result.isError) {\r\n                    this.privDialogRequestSession.onAuthCompleted(true, result.error);\r\n                    throw new Error(result.error);\r\n                } else {\r\n                    this.privDialogRequestSession.onAuthCompleted(false);\r\n                }\r\n\r\n                const connection: IConnection = this.privDialogConnectionFactory.create(this.privRecognizerConfig, result.result, this.privConnectionId);\r\n\r\n                this.privDialogRequestSession.listenForServiceTelemetry(connection.events);\r\n\r\n                // Attach to the underlying event. No need to hold onto the detach pointers as in the event the connection goes away,\r\n                // it'll stop sending events.\r\n                connection.events.attach((event: ConnectionEvent) => {\r\n                    this.connectionEvents.onEvent(event);\r\n                });\r\n\r\n                return connection.open().onSuccessContinueWithPromise((response: ConnectionOpenResponse): Promise<IConnection> => {\r\n                    if (response.statusCode === 200) {\r\n                        this.privDialogRequestSession.onPreConnectionStart(this.privDialogAuthFetchEventId, this.privConnectionId);\r\n                        this.privDialogRequestSession.onConnectionEstablishCompleted(response.statusCode);\r\n\r\n                        return PromiseHelper.fromResult<IConnection>(connection);\r\n                    } else if (response.statusCode === 403 && !isUnAuthorized) {\r\n                        return this.dialogConnectImpl(true);\r\n                    } else {\r\n                        this.privDialogRequestSession.onConnectionEstablishCompleted(response.statusCode, response.reason);\r\n                        return PromiseHelper.fromError<IConnection>(`Unable to contact server. StatusCode: ${response.statusCode}, ${this.privRecognizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${response.reason}`);\r\n                    }\r\n                });\r\n            });\r\n\r\n        this.privConnectionLoop = this.startMessageLoop();\r\n        return this.privDialogConnectionPromise;\r\n    }\r\n\r\n    private receiveDialogMessageOverride = (): Promise<IConnection> => {\r\n\r\n        // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages\r\n        const communicationCustodian: Deferred<IConnection> = new Deferred<IConnection>();\r\n\r\n        this.fetchDialogConnection().on((connection: IConnection): Promise<IConnection> => {\r\n            return connection.read()\r\n                .onSuccessContinueWithPromise((message: ConnectionMessage): Promise<IConnection> => {\r\n                    const isDisposed: boolean = this.isDisposed();\r\n                    const terminateMessageLoop = (!this.isDisposed() && this.terminateMessageLoop);\r\n                    if (isDisposed || terminateMessageLoop) {\r\n                        // We're done.\r\n                        communicationCustodian.resolve(undefined);\r\n                        return PromiseHelper.fromResult<IConnection>(undefined);\r\n                    }\r\n\r\n                    if (!message) {\r\n                        return this.receiveDialogMessageOverride();\r\n                    }\r\n\r\n                    const connectionMessage = SpeechConnectionMessage.fromConnectionMessage(message);\r\n\r\n                    switch (connectionMessage.path.toLowerCase()) {\r\n                        case \"turn.start\":\r\n                            {\r\n                                const turnRequestId = connectionMessage.requestId.toUpperCase();\r\n                                const audioSessionReqId = this.privDialogRequestSession.requestId.toUpperCase();\r\n\r\n                                // turn started by the service\r\n                                if (turnRequestId !== audioSessionReqId) {\r\n                                    this.privTurnStateManager.StartTurn(turnRequestId);\r\n                                } else {\r\n                                    this.privDialogRequestSession.onServiceTurnStartResponse();\r\n                                }\r\n                            }\r\n                            break;\r\n                        case \"speech.startdetected\":\r\n                            const speechStartDetected: SpeechDetected = SpeechDetected.fromJSON(connectionMessage.textBody);\r\n\r\n                            const speechStartEventArgs = new RecognitionEventArgs(speechStartDetected.Offset, this.privDialogRequestSession.sessionId);\r\n\r\n                            if (!!this.privRecognizer.speechStartDetected) {\r\n                                this.privRecognizer.speechStartDetected(this.privRecognizer, speechStartEventArgs);\r\n                            }\r\n\r\n                            break;\r\n                        case \"speech.enddetected\":\r\n\r\n                            let json: string;\r\n\r\n                            if (connectionMessage.textBody.length > 0) {\r\n                                json = connectionMessage.textBody;\r\n                            } else {\r\n                                // If the request was empty, the JSON returned is empty.\r\n                                json = \"{ Offset: 0 }\";\r\n                            }\r\n\r\n                            const speechStopDetected: SpeechDetected = SpeechDetected.fromJSON(json);\r\n\r\n                            this.privDialogRequestSession.onServiceRecognized(speechStopDetected.Offset + this.privDialogRequestSession.currentTurnAudioOffset);\r\n\r\n                            const speechStopEventArgs = new RecognitionEventArgs(speechStopDetected.Offset + this.privDialogRequestSession.currentTurnAudioOffset, this.privDialogRequestSession.sessionId);\r\n\r\n                            if (!!this.privRecognizer.speechEndDetected) {\r\n                                this.privRecognizer.speechEndDetected(this.privRecognizer, speechStopEventArgs);\r\n                            }\r\n                            break;\r\n\r\n                        case \"turn.end\":\r\n                            {\r\n                                const turnEndRequestId = connectionMessage.requestId.toUpperCase();\r\n\r\n                                const audioSessionReqId = this.privDialogRequestSession.requestId.toUpperCase();\r\n\r\n                                // turn started by the service\r\n                                if (turnEndRequestId !== audioSessionReqId) {\r\n                                    this.privTurnStateManager.CompleteTurn(turnEndRequestId);\r\n                                } else {\r\n                                    // Audio session turn\r\n\r\n                                    const sessionStopEventArgs: SessionEventArgs = new SessionEventArgs(this.privDialogRequestSession.sessionId);\r\n                                    this.privDialogRequestSession.onServiceTurnEndResponse(false);\r\n\r\n                                    if (this.privDialogRequestSession.isSpeechEnded) {\r\n                                        if (!!this.privRecognizer.sessionStopped) {\r\n                                            this.privRecognizer.sessionStopped(this.privRecognizer, sessionStopEventArgs);\r\n                                        }\r\n                                    }\r\n\r\n                                    // report result to promise.\r\n                                    if (!!this.privSuccessCallback && this.privLastResult) {\r\n                                        try {\r\n                                            this.privSuccessCallback(this.privLastResult);\r\n                                            this.privLastResult = null;\r\n                                        } catch (e) {\r\n                                            if (!!this.privErrorCallback) {\r\n                                                this.privErrorCallback(e);\r\n                                            }\r\n                                        }\r\n                                        // Only invoke the call back once.\r\n                                        // and if it's successful don't invoke the\r\n                                        // error after that.\r\n                                        this.privSuccessCallback = undefined;\r\n                                        this.privErrorCallback = undefined;\r\n                                    }\r\n                                }\r\n                            }\r\n                            break;\r\n\r\n                        default:\r\n                            if (!this.processTypeSpecificMessages(connectionMessage)) {\r\n                                if (!!this.serviceEvents) {\r\n                                    this.serviceEvents.onEvent(new ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));\r\n                                }\r\n                            }\r\n                    }\r\n\r\n                    return this.receiveDialogMessageOverride();\r\n                });\r\n        }, (error: string) => {\r\n            this.terminateMessageLoop = true;\r\n            communicationCustodian.resolve(undefined);\r\n            return PromiseHelper.fromResult<IConnection>(undefined);\r\n        });\r\n\r\n        return communicationCustodian.promise();\r\n    }\r\n\r\n    private startMessageLoop(): Promise<IConnection> {\r\n\r\n        this.terminateMessageLoop = false;\r\n\r\n        const messageRetrievalPromise = this.receiveDialogMessageOverride();\r\n\r\n        return messageRetrievalPromise.on((r: IConnection) => {\r\n            return true;\r\n        }, (error: string) => {\r\n            this.cancelRecognition(this.privDialogRequestSession.sessionId, this.privDialogRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\r\n        });\r\n    }\r\n\r\n    // Takes an established websocket connection to the endpoint and sends speech configuration information.\r\n    private configConnection(): Promise<IConnection> {\r\n        if (this.privConnectionConfigPromise) {\r\n            if (this.privConnectionConfigPromise.result().isCompleted &&\r\n                (this.privConnectionConfigPromise.result().isError\r\n                    || this.privConnectionConfigPromise.result().result.state() === ConnectionState.Disconnected)) {\r\n\r\n                this.privConnectionConfigPromise = null;\r\n                return this.configConnection();\r\n            } else {\r\n                return this.privConnectionConfigPromise;\r\n            }\r\n        }\r\n\r\n        if (this.terminateMessageLoop) {\r\n            this.terminateMessageLoop = false;\r\n            return PromiseHelper.fromError(`Connection to service terminated.`);\r\n        }\r\n\r\n        this.privConnectionConfigPromise = this.dialogConnectImpl().onSuccessContinueWithPromise((connection: IConnection): Promise<IConnection> => {\r\n            return this.sendSpeechServiceConfig(connection, this.privDialogRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize())\r\n                .onSuccessContinueWithPromise((_: boolean) => {\r\n                    return this.sendAgentConfig(connection).onSuccessContinueWith((_: boolean) => {\r\n                        return connection;\r\n                    });\r\n                });\r\n        });\r\n\r\n        return this.privConnectionConfigPromise;\r\n    }\r\n\r\n    private fetchDialogConnection = (): Promise<IConnection> => {\r\n        return this.configConnection();\r\n    }\r\n\r\n    private sendPreAudioMessages(): void {\r\n        this.fetchDialogConnection().onSuccessContinueWith((connection: IConnection): void => {\r\n            this.sendAgentContext(connection);\r\n            this.sendWaveHeader(connection);\r\n        });\r\n    }\r\n\r\n    private sendAgentConfig = (connection: IConnection): Promise<boolean> => {\r\n        if (this.agentConfig && !this.agentConfigSent) {\r\n\r\n            if (this.privRecognizerConfig.parameters.getProperty(PropertyId.Conversation_DialogType) === \"custom_commands\") {\r\n                const config = this.agentConfig.get();\r\n                config.botInfo.commandsCulture = this.privRecognizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage, \"en-us\");\r\n                this.agentConfig.set(config);\r\n            }\r\n            const agentConfigJson = this.agentConfig.toJsonString();\r\n\r\n            // guard against sending this multiple times on one connection\r\n            this.agentConfigSent = true;\r\n\r\n            return connection.send(new SpeechConnectionMessage(\r\n                MessageType.Text,\r\n                \"agent.config\",\r\n                this.privDialogRequestSession.requestId,\r\n                \"application/json\",\r\n                agentConfigJson));\r\n        }\r\n\r\n        return PromiseHelper.fromResult(true);\r\n    }\r\n\r\n    private sendAgentContext = (connection: IConnection): Promise<boolean> => {\r\n        const guid: string = createGuid();\r\n\r\n        const speechActivityTemplate = this.privDialogServiceConnector.properties.getProperty(PropertyId.Conversation_Speech_Activity_Template);\r\n\r\n        const agentContext: any = {\r\n            channelData: \"\",\r\n            context: {\r\n                interactionId: guid\r\n            },\r\n            messagePayload: typeof speechActivityTemplate === undefined ? undefined : speechActivityTemplate,\r\n            version: 0.5\r\n        };\r\n\r\n        const agentContextJson = JSON.stringify(agentContext);\r\n\r\n        return connection.send(new SpeechConnectionMessage(\r\n            MessageType.Text,\r\n            \"speech.agent.context\",\r\n            this.privDialogRequestSession.requestId,\r\n            \"application/json\",\r\n            agentContextJson));\r\n    }\r\n\r\n    private fireEventForResult(serviceResult: SimpleSpeechPhrase, properties: PropertyCollection): SpeechRecognitionEventArgs {\r\n        const resultReason: ResultReason = EnumTranslation.implTranslateRecognitionResult(serviceResult.RecognitionStatus);\r\n\r\n        const offset: number = serviceResult.Offset + this.privDialogRequestSession.currentTurnAudioOffset;\r\n\r\n        const result = new SpeechRecognitionResult(\r\n            this.privDialogRequestSession.requestId,\r\n            resultReason,\r\n            serviceResult.DisplayText,\r\n            serviceResult.Duration,\r\n            offset,\r\n            serviceResult.Language,\r\n            serviceResult.LanguageDetectionConfidence,\r\n            undefined,\r\n            JSON.stringify(serviceResult),\r\n            properties);\r\n\r\n        const ev = new SpeechRecognitionEventArgs(result, offset, this.privDialogRequestSession.sessionId);\r\n        return ev;\r\n    }\r\n}\r\n"]}