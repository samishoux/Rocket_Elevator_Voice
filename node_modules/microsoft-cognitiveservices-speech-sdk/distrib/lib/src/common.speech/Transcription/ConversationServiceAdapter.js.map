{"version":3,"sources":["src/common.speech/Transcription/ConversationServiceAdapter.ts"],"names":[],"mappings":"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","file":"ConversationServiceAdapter.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    ConnectionEvent,\r\n    ConnectionMessage,\r\n    ConnectionOpenResponse,\r\n    ConnectionState,\r\n    createNoDashGuid,\r\n    Deferred,\r\n    IAudioSource,\r\n    IConnection,\r\n    MessageType,\r\n    Promise,\r\n    PromiseHelper,\r\n    PromiseResult\r\n} from \"../../common/Exports\";\r\nimport { Sink } from \"../../common/Promise\";\r\nimport {\r\n    CancellationErrorCode,\r\n    CancellationReason,\r\n    ConversationExpirationEventArgs,\r\n    ConversationTranslationCanceledEventArgs,\r\n    ConversationTranslationResult,\r\n    PropertyId,\r\n    SessionEventArgs,\r\n    SpeechRecognitionResult,\r\n    Translations\r\n} from \"../../sdk/Exports\";\r\nimport {\r\n    AuthInfo, IAuthentication, IConnectionFactory, RecognizerConfig, ServiceRecognizerBase\r\n} from \"../Exports\";\r\nimport { ConversationConnectionMessage } from \"./ConversationConnectionMessage\";\r\nimport { ConversationRequestSession } from \"./ConversationRequestSession\";\r\nimport {\r\n    ConversationReceivedTranslationEventArgs,\r\n    LockRoomEventArgs,\r\n    MuteAllEventArgs,\r\n    ParticipantAttributeEventArgs,\r\n    ParticipantEventArgs,\r\n    ParticipantsListEventArgs\r\n} from \"./ConversationTranslatorEventArgs\";\r\nimport { ConversationTranslatorCommandTypes, ConversationTranslatorMessageTypes, IInternalParticipant } from \"./ConversationTranslatorInterfaces\";\r\nimport { ConversationTranslatorRecognizer } from \"./ConversationTranslatorRecognizer\";\r\nimport {\r\n    CommandResponsePayload,\r\n    IParticipantPayloadResponse,\r\n    IParticipantsListPayloadResponse,\r\n    ITranslationResponsePayload,\r\n    ParticipantPayloadResponse,\r\n    ParticipantsListPayloadResponse,\r\n    SpeechResponsePayload,\r\n    TextResponsePayload\r\n} from \"./ServiceMessages/Exports\";\r\n\r\n/***\r\n * The service adapter handles sending and receiving messages to the Conversation Translator websocket.\r\n */\r\nexport class ConversationServiceAdapter extends ServiceRecognizerBase {\r\n    private privConversationServiceConnector: ConversationTranslatorRecognizer;\r\n    private privConversationConnectionFactory: IConnectionFactory;\r\n    private privConversationAuthFetchEventId: string;\r\n    private privConversationAuthentication: IAuthentication;\r\n    private privConversationRequestSession: ConversationRequestSession;\r\n    private privConnectionConfigPromise: Promise<IConnection>;\r\n    private privConversationConnectionPromise: Promise<IConnection>;\r\n    private privConnectionLoop: Promise<IConnection>;\r\n    private terminateMessageLoop: boolean;\r\n    private privLastPartialUtteranceId: string = \"\";\r\n    private privConversationIsDisposed: boolean;\r\n\r\n    public constructor(\r\n        authentication: IAuthentication,\r\n        connectionFactory: IConnectionFactory,\r\n        audioSource: IAudioSource,\r\n        recognizerConfig: RecognizerConfig,\r\n        conversationServiceConnector: ConversationTranslatorRecognizer) {\r\n\r\n        super(authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector);\r\n\r\n        this.privConversationServiceConnector = conversationServiceConnector;\r\n        this.privConversationAuthentication = authentication;\r\n        this.receiveMessageOverride = this.receiveConversationMessageOverride;\r\n        this.recognizeOverride = this.noOp;\r\n        this.connectImplOverride = this.conversationConnectImpl;\r\n        this.configConnectionOverride = this.configConnection;\r\n        this.fetchConnectionOverride = this.fetchConversationConnection;\r\n        this.disconnectOverride = this.privDisconnect;\r\n        this.privConversationRequestSession = new ConversationRequestSession(createNoDashGuid());\r\n        this.privConversationConnectionFactory = connectionFactory;\r\n        this.privConversationIsDisposed = false;\r\n    }\r\n\r\n    public isDisposed(): boolean {\r\n        return this.privConversationIsDisposed;\r\n    }\r\n\r\n    public dispose(reason?: string): void {\r\n        this.privConversationIsDisposed = true;\r\n        if (this.privConnectionConfigPromise) {\r\n            this.privConnectionConfigPromise.onSuccessContinueWith((connection: IConnection) => {\r\n                connection.dispose(reason);\r\n            });\r\n        }\r\n    }\r\n\r\n    public sendMessage(message: string): void {\r\n        this.fetchConversationConnection().onSuccessContinueWith((connection: IConnection) => {\r\n            connection.send(new ConversationConnectionMessage(\r\n                MessageType.Text,\r\n                message));\r\n        });\r\n    }\r\n\r\n    public sendMessageAsync = (message: string): Promise<boolean> => {\r\n        const sink: Sink<boolean> = new Sink<boolean>();\r\n\r\n        this.fetchConversationConnection().continueWith((antecedent: PromiseResult<IConnection>): void => {\r\n            try {\r\n                if (antecedent.isError) {\r\n                    sink.reject(antecedent.error);\r\n                } else {\r\n                    antecedent.result.send(new ConversationConnectionMessage(MessageType.Text, message))\r\n                        .continueWith((innerAntecedent: PromiseResult<boolean>): void => {\r\n                            try {\r\n                                if (innerAntecedent.isError) {\r\n                                    sink.reject(innerAntecedent.error);\r\n                                } else {\r\n                                    sink.resolve(innerAntecedent.result);\r\n                                }\r\n                            } catch (e) {\r\n                                sink.reject(`Unhandled inner error: ${e}`);\r\n                            }\r\n                        });\r\n                }\r\n            } catch (e) {\r\n                sink.reject(`Unhandled error: ${e}`);\r\n            }\r\n        });\r\n\r\n        return new Promise<boolean>(sink);\r\n    }\r\n\r\n    protected privDisconnect(): void {\r\n        if (this.terminateMessageLoop) {\r\n            return;\r\n        }\r\n        this.cancelRecognition(this.privConversationRequestSession.sessionId,\r\n            this.privConversationRequestSession.requestId,\r\n            CancellationReason.Error,\r\n            CancellationErrorCode.NoError,\r\n            \"Disconnecting\");\r\n\r\n        this.terminateMessageLoop = true;\r\n        if (this.privConversationConnectionPromise.result().isCompleted) {\r\n            if (!this.privConversationConnectionPromise.result().isError) {\r\n                this.privConversationConnectionPromise.result().result.dispose();\r\n                this.privConversationConnectionPromise = null;\r\n            }\r\n        } else {\r\n            this.privConversationConnectionPromise.onSuccessContinueWith((connection: IConnection) => {\r\n                connection.dispose();\r\n            });\r\n        }\r\n    }\r\n\r\n    protected processTypeSpecificMessages(\r\n        connectionMessage: ConnectionMessage,\r\n        successCallback?: (e: any) => void,\r\n        errorCallBack?: (e: string) => void): boolean {\r\n        return true;\r\n    }\r\n\r\n    // Cancels recognition.\r\n    protected cancelRecognition(\r\n        sessionId: string,\r\n        requestId: string,\r\n        cancellationReason: CancellationReason,\r\n        errorCode: CancellationErrorCode,\r\n        error: string): void {\r\n\r\n        this.terminateMessageLoop = true;\r\n\r\n        const cancelEvent: ConversationTranslationCanceledEventArgs = new ConversationTranslationCanceledEventArgs(\r\n            cancellationReason,\r\n            error,\r\n            errorCode,\r\n            undefined,\r\n            sessionId);\r\n\r\n        try {\r\n            if (!!this.privConversationServiceConnector.canceled) {\r\n                this.privConversationServiceConnector.canceled(this.privConversationServiceConnector, cancelEvent);\r\n            }\r\n        } catch {\r\n            // continue on error\r\n        }\r\n    }\r\n\r\n    protected noOp = (): any => {\r\n        // operation not supported\r\n    }\r\n\r\n    /**\r\n     * Establishes a websocket connection to the end point.\r\n     * @param isUnAuthorized\r\n     */\r\n    protected conversationConnectImpl(isUnAuthorized: boolean = false): Promise<IConnection> {\r\n\r\n        if (this.privConversationConnectionPromise) {\r\n            if (this.privConversationConnectionPromise.result().isCompleted &&\r\n                (this.privConversationConnectionPromise.result().isError\r\n                    || this.privConversationConnectionPromise.result().result.state() === ConnectionState.Disconnected)) {\r\n                this.privConnectionId = null;\r\n                this.privConversationConnectionPromise = null;\r\n                this.terminateMessageLoop = true;\r\n                return this.conversationConnectImpl();\r\n            } else {\r\n                return this.privConversationConnectionPromise;\r\n            }\r\n        }\r\n\r\n        this.privConversationAuthFetchEventId = createNoDashGuid();\r\n\r\n        // keep the connectionId for reconnect events\r\n        if (this.privConnectionId === undefined) {\r\n            this.privConnectionId = createNoDashGuid();\r\n        }\r\n\r\n        this.privConversationRequestSession.onPreConnectionStart(this.privConversationAuthFetchEventId, this.privConnectionId);\r\n\r\n        const authPromise = isUnAuthorized ? this.privConversationAuthentication.fetchOnExpiry(this.privConversationAuthFetchEventId) : this.privConversationAuthentication.fetch(this.privConversationAuthFetchEventId);\r\n\r\n        this.privConversationConnectionPromise = authPromise\r\n            .continueWithPromise((result: PromiseResult<AuthInfo>) => {\r\n                if (result.isError) {\r\n                    this.privConversationRequestSession.onAuthCompleted(true, result.error);\r\n                    throw new Error(result.error);\r\n                } else {\r\n                    this.privConversationRequestSession.onAuthCompleted(false);\r\n                }\r\n\r\n                const connection: IConnection = this.privConversationConnectionFactory.create(this.privRecognizerConfig, result.result, this.privConnectionId);\r\n\r\n                // Attach to the underlying event. No need to hold onto the detach pointers as in the event the connection goes away,\r\n                // it'll stop sending events.\r\n                connection.events.attach((event: ConnectionEvent) => {\r\n                    this.connectionEvents.onEvent(event);\r\n                });\r\n\r\n                return connection.open().onSuccessContinueWithPromise((response: ConnectionOpenResponse): Promise<IConnection> => {\r\n                    if (response.statusCode === 200) {\r\n                        this.privConversationRequestSession.onPreConnectionStart(this.privConversationAuthFetchEventId, this.privConnectionId);\r\n                        this.privConversationRequestSession.onConnectionEstablishCompleted(response.statusCode);\r\n                        const sessionStartEventArgs: SessionEventArgs = new SessionEventArgs(this.privConversationRequestSession.sessionId);\r\n                        if (!!this.privConversationServiceConnector.connectionOpened) {\r\n                            this.privConversationServiceConnector.connectionOpened(this.privConversationServiceConnector, sessionStartEventArgs);\r\n                        }\r\n                        return PromiseHelper.fromResult<IConnection>(connection);\r\n                    } else if (response.statusCode === 403 && !isUnAuthorized) {\r\n                        return this.conversationConnectImpl(true);\r\n                    } else {\r\n                        this.privConversationRequestSession.onConnectionEstablishCompleted(response.statusCode, response.reason);\r\n                        return PromiseHelper.fromError<IConnection>(`Unable to contact server. StatusCode: ${response.statusCode}, ${this.privRecognizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${response.reason}`);\r\n                    }\r\n                });\r\n            });\r\n\r\n        this.privConnectionLoop = this.startMessageLoop();\r\n        return this.privConversationConnectionPromise;\r\n    }\r\n\r\n    /**\r\n     * Process incoming websocket messages\r\n     */\r\n    private receiveConversationMessageOverride = (\r\n        successCallback?: (e: any) => void,\r\n        errorCallBack?: (e: string) => void\r\n    ): Promise<IConnection> => {\r\n\r\n        // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages\r\n        const communicationCustodian: Deferred<IConnection> = new Deferred<IConnection>();\r\n\r\n        this.fetchConversationConnection().on((connection: IConnection): Promise<IConnection> => {\r\n            return connection.read().onSuccessContinueWithPromise((message: ConversationConnectionMessage): Promise<IConnection> => {\r\n                const isDisposed: boolean = this.isDisposed();\r\n                const terminateMessageLoop = (!this.isDisposed() && this.terminateMessageLoop);\r\n                const sessionId: string = this.privConversationRequestSession.sessionId;\r\n                let sendFinal: boolean = false;\r\n                if (isDisposed || terminateMessageLoop) {\r\n                    // We're done.\r\n                    communicationCustodian.resolve(undefined);\r\n                    return PromiseHelper.fromResult<IConnection>(undefined);\r\n                }\r\n\r\n                if (!message) {\r\n                    return this.receiveConversationMessageOverride();\r\n                }\r\n\r\n                try {\r\n                    switch (message.conversationMessageType.toLowerCase()) {\r\n                        case \"info\":\r\n                        case \"participant_command\":\r\n                        case \"command\":\r\n                            const commandPayload: CommandResponsePayload = CommandResponsePayload.fromJSON(message.textBody);\r\n                            switch (commandPayload.command.toLowerCase()) {\r\n\r\n                                /**\r\n                                 * 'ParticpantList' is the first message sent to the user after the websocket connection has opened.\r\n                                 * The consuming client must wait for this message to arrive\r\n                                 * before starting to send their own data.\r\n                                 */\r\n                                case \"participantlist\":\r\n\r\n                                    const participantsPayload: IParticipantsListPayloadResponse = ParticipantsListPayloadResponse.fromJSON(message.textBody);\r\n\r\n                                    const participantsResult: IInternalParticipant[] = participantsPayload.participants.map((p: IParticipantPayloadResponse) => {\r\n                                        const participant: IInternalParticipant = {\r\n                                            avatar: p.avatar,\r\n                                            displayName: p.nickname,\r\n                                            id: p.participantId,\r\n                                            isHost: p.ishost,\r\n                                            isMuted: p.ismuted,\r\n                                            isUsingTts: p.usetts,\r\n                                            preferredLanguage: p.locale\r\n                                        };\r\n                                        return participant;\r\n                                    });\r\n\r\n                                    if (!!this.privConversationServiceConnector.participantsListReceived) {\r\n                                        this.privConversationServiceConnector.participantsListReceived(this.privConversationServiceConnector,\r\n                                            new ParticipantsListEventArgs(participantsPayload.roomid, participantsPayload.token,\r\n                                                participantsPayload.translateTo, participantsPayload.profanityFilter,\r\n                                                participantsPayload.roomProfanityFilter, participantsPayload.roomLocked,\r\n                                                participantsPayload.muteAll, participantsResult, sessionId));\r\n                                    }\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'SetTranslateToLanguages' represents the list of languages being used in the Conversation by all users(?).\r\n                                 * This is sent at the start of the Conversation\r\n                                 */\r\n                                case \"settranslatetolanguages\":\r\n\r\n                                    if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                        this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                            new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                                ConversationTranslatorCommandTypes.setTranslateToLanguages,\r\n                                                commandPayload.value, sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'SetProfanityFiltering' lets the client set the level of profanity filtering.\r\n                                 * If sent by the participant the setting will effect only their own profanity level.\r\n                                 * If sent by the host, the setting will effect all participants including the host.\r\n                                 * Note: the profanity filters differ from Speech Service (?): 'marked', 'raw', 'removed', 'tagged'\r\n                                 */\r\n                                case \"setprofanityfiltering\":\r\n\r\n                                    if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                        this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                            new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                                ConversationTranslatorCommandTypes.setProfanityFiltering,\r\n                                                commandPayload.value, sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'SetMute' is sent if the participant has been muted by the host.\r\n                                 * Check the 'participantId' to determine if the current user has been muted.\r\n                                 */\r\n                                case \"setmute\":\r\n\r\n                                    if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                        this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                            new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                                ConversationTranslatorCommandTypes.setMute,\r\n                                                commandPayload.value, sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'SetMuteAll' is sent if the Conversation has been muted by the host.\r\n                                 */\r\n                                case \"setmuteall\":\r\n\r\n                                    if (!!this.privConversationServiceConnector.muteAllCommandReceived) {\r\n                                        this.privConversationServiceConnector.muteAllCommandReceived(this.privConversationServiceConnector,\r\n                                            new MuteAllEventArgs(commandPayload.value as boolean, sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'RoomExpirationWarning' is sent towards the end of the Conversation session to give a timeout warning.\r\n                                 */\r\n                                case \"roomexpirationwarning\":\r\n\r\n                                    if (!!this.privConversationServiceConnector.conversationExpiration) {\r\n                                        this.privConversationServiceConnector.conversationExpiration(this.privConversationServiceConnector,\r\n                                            new ConversationExpirationEventArgs(commandPayload.value as number, this.privConversationRequestSession.sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'SetUseTts' is sent as a confirmation if the user requests TTS to be turned on or off.\r\n                                 */\r\n                                case \"setusetts\":\r\n\r\n                                    if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                        this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                            new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                                ConversationTranslatorCommandTypes.setUseTTS,\r\n                                                commandPayload.value, sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'SetLockState' is set if the host has locked or unlocked the Conversation.\r\n                                 */\r\n                                case \"setlockstate\":\r\n\r\n                                    if (!!this.privConversationServiceConnector.lockRoomCommandReceived) {\r\n                                        this.privConversationServiceConnector.lockRoomCommandReceived(this.privConversationServiceConnector,\r\n                                            new LockRoomEventArgs(commandPayload.value as boolean, sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'ChangeNickname' is received if a user changes their display name.\r\n                                 * Any cached particpiants list should be updated to reflect the display name.\r\n                                 */\r\n                                case \"changenickname\":\r\n\r\n                                    if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                        this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                            new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                                ConversationTranslatorCommandTypes.changeNickname,\r\n                                                commandPayload.nickname, sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'JoinSession' is sent when a user joins the Conversation.\r\n                                 */\r\n                                case \"joinsession\":\r\n\r\n                                    const joinParticipantPayload: ParticipantPayloadResponse = ParticipantPayloadResponse.fromJSON(message.textBody);\r\n\r\n                                    const joiningParticipant: IInternalParticipant = {\r\n                                        avatar: joinParticipantPayload.avatar,\r\n                                        displayName: joinParticipantPayload.nickname,\r\n                                        id: joinParticipantPayload.participantId,\r\n                                        isHost: joinParticipantPayload.ishost,\r\n                                        isMuted: joinParticipantPayload.ismuted,\r\n                                        isUsingTts: joinParticipantPayload.usetts,\r\n                                        preferredLanguage: joinParticipantPayload.locale,\r\n                                    };\r\n\r\n                                    if (!!this.privConversationServiceConnector.participantJoinCommandReceived) {\r\n                                        this.privConversationServiceConnector.participantJoinCommandReceived(this.privConversationServiceConnector,\r\n                                            new ParticipantEventArgs(\r\n                                                joiningParticipant,\r\n                                                sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'LeaveSession' is sent when a user leaves the Conversation'.\r\n                                 */\r\n                                case \"leavesession\":\r\n\r\n                                    const leavingParticipant: IInternalParticipant = {\r\n                                        id: commandPayload.participantId\r\n                                    };\r\n\r\n                                    if (!!this.privConversationServiceConnector.participantLeaveCommandReceived) {\r\n                                        this.privConversationServiceConnector.participantLeaveCommandReceived(this.privConversationServiceConnector,\r\n                                            new ParticipantEventArgs(leavingParticipant, sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'DisconnectSession' is sent when a user is disconnected from the session (e.g. network problem).\r\n                                 * Check the 'ParticipantId' to check whether the message is for the current user.\r\n                                 */\r\n                                case \"disconnectsession\":\r\n\r\n                                    const disconnectParticipant: IInternalParticipant = {\r\n                                        id: commandPayload.participantId\r\n                                    };\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * Message not recognized.\r\n                                 */\r\n                                default:\r\n                                    break;\r\n                            }\r\n                            break;\r\n\r\n                        /**\r\n                         * 'partial' (or 'hypothesis') represents a unfinalized speech message.\r\n                         */\r\n                        case \"partial\":\r\n\r\n                        /**\r\n                         * 'final' (or 'phrase') represents a finalized speech message.\r\n                         */\r\n                        case \"final\":\r\n\r\n                            const speechPayload: SpeechResponsePayload = SpeechResponsePayload.fromJSON(message.textBody);\r\n\r\n                            const speechResult: ConversationTranslationResult = new ConversationTranslationResult(speechPayload.participantId,\r\n                                this.getTranslations(speechPayload.translations),\r\n                                speechPayload.language,\r\n                                undefined,\r\n                                undefined,\r\n                                speechPayload.recognition,\r\n                                undefined,\r\n                                undefined,\r\n                                message.textBody,\r\n                                undefined);\r\n\r\n                            if (speechPayload.isFinal) {\r\n                                // check the length, sometimes empty finals are returned\r\n                                if (speechResult.text !== undefined && speechResult.text.length > 0) {\r\n                                    sendFinal = true;\r\n                                } else if (speechPayload.id === this.privLastPartialUtteranceId) {\r\n                                    // send final as normal. We had a non-empty partial for this same utterance\r\n                                    // so sending the empty final is important\r\n                                    sendFinal = true;\r\n                                } else {\r\n                                    // suppress unneeded final\r\n                                }\r\n\r\n                                if (sendFinal) {\r\n                                    if (!!this.privConversationServiceConnector.translationReceived) {\r\n                                        this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector,\r\n                                            new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.final, speechResult, sessionId));\r\n                                    }\r\n                                }\r\n                            } else if (speechResult.text !== undefined) {\r\n                                this.privLastPartialUtteranceId = speechPayload.id;\r\n                                if (!!this.privConversationServiceConnector.translationReceived) {\r\n                                    this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector,\r\n                                        new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.partial, speechResult, sessionId));\r\n                                }\r\n                            }\r\n\r\n                            break;\r\n\r\n                        /**\r\n                         * \"translated_message\" is a text message or instant message (IM).\r\n                         */\r\n                        case \"translated_message\":\r\n\r\n                            const textPayload: TextResponsePayload = TextResponsePayload.fromJSON(message.textBody);\r\n\r\n                            const textResult: ConversationTranslationResult = new ConversationTranslationResult(textPayload.participantId,\r\n                                this.getTranslations(textPayload.translations),\r\n                                textPayload.language,\r\n                                undefined,\r\n                                undefined,\r\n                                textPayload.originalText,\r\n                                undefined,\r\n                                undefined,\r\n                                undefined,\r\n                                message.textBody,\r\n                                undefined);\r\n\r\n                            if (!!this.privConversationServiceConnector.translationReceived) {\r\n                                this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector,\r\n                                    new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.instantMessage, textResult, sessionId));\r\n                            }\r\n                            break;\r\n\r\n                        default:\r\n                            // ignore any unsupported message types\r\n                            break;\r\n                    }\r\n                } catch (e) {\r\n                    // continue\r\n                }\r\n                return this.receiveConversationMessageOverride();\r\n            });\r\n        }, (error: string) => {\r\n            this.terminateMessageLoop = true;\r\n        });\r\n\r\n        return communicationCustodian.promise();\r\n    }\r\n\r\n    private startMessageLoop(): Promise<IConnection> {\r\n\r\n        this.terminateMessageLoop = false;\r\n\r\n        const messageRetrievalPromise = this.receiveConversationMessageOverride();\r\n\r\n        return messageRetrievalPromise.on((r: IConnection) => {\r\n            return true;\r\n        }, (error: string) => {\r\n            this.cancelRecognition(\r\n                this.privRequestSession ? this.privRequestSession.sessionId : \"\",\r\n                this.privRequestSession ? this.privRequestSession.requestId : \"\",\r\n                CancellationReason.Error,\r\n                CancellationErrorCode.RuntimeError,\r\n                error);\r\n        });\r\n    }\r\n\r\n    // Takes an established websocket connection to the endpoint\r\n    private configConnection(): Promise<IConnection> {\r\n        if (this.privConnectionConfigPromise) {\r\n            if (this.privConnectionConfigPromise.result().isCompleted &&\r\n                (this.privConnectionConfigPromise.result().isError\r\n                    || this.privConnectionConfigPromise.result().result.state() === ConnectionState.Disconnected)) {\r\n\r\n                this.privConnectionConfigPromise = null;\r\n                return this.configConnection();\r\n            } else {\r\n                return this.privConnectionConfigPromise;\r\n            }\r\n        }\r\n\r\n        if (this.terminateMessageLoop) {\r\n            return PromiseHelper.fromResult<IConnection>(undefined);\r\n        }\r\n\r\n        this.privConnectionConfigPromise = this.conversationConnectImpl()\r\n            .onSuccessContinueWith((connection: IConnection): any => {\r\n                return connection;\r\n            });\r\n        return this.privConnectionConfigPromise;\r\n    }\r\n\r\n    private getTranslations(serviceResultTranslations: ITranslationResponsePayload[]): Translations {\r\n        let translations: Translations;\r\n\r\n        if (undefined !== serviceResultTranslations) {\r\n            translations = new Translations();\r\n            for (const translation of serviceResultTranslations) {\r\n                translations.set(translation.lang, translation.translation);\r\n            }\r\n        }\r\n\r\n        return translations;\r\n    }\r\n\r\n    private fetchConversationConnection = (): Promise<IConnection> => {\r\n        return this.configConnection();\r\n    }\r\n\r\n}\r\n"]}