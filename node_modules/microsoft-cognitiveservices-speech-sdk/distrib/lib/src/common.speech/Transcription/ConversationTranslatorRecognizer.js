"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Exports_1 = require("../../common.speech/Exports");
var Contracts_1 = require("../../sdk/Contracts");
var Exports_2 = require("../../sdk/Exports");
var ConversationConnectionFactory_1 = require("./ConversationConnectionFactory");
var ConversationServiceAdapter_1 = require("./ConversationServiceAdapter");
var ConversationTranslatorInterfaces_1 = require("./ConversationTranslatorInterfaces");
var ConversationUtils_1 = require("./ConversationUtils");
/**
 * Sends messages to the Conversation Translator websocket and listens for incoming events containing websocket messages.
 * Based off the recognizers in the SDK folder.
 */
var ConversationTranslatorRecognizer = /** @class */ (function (_super) {
    __extends(ConversationTranslatorRecognizer, _super);
    function ConversationTranslatorRecognizer(speechConfig, audioConfig) {
        var _this = this;
        var serviceConfigImpl = speechConfig;
        Contracts_1.Contracts.throwIfNull(serviceConfigImpl, "speechConfig");
        _this = _super.call(this, audioConfig, serviceConfigImpl.properties, new ConversationConnectionFactory_1.ConversationConnectionFactory()) || this;
        _this.privIsDisposed = false;
        _this.privProperties = serviceConfigImpl.properties.clone();
        return _this;
    }
    Object.defineProperty(ConversationTranslatorRecognizer.prototype, "conversation", {
        set: function (value) {
            this.privRoom = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConversationTranslatorRecognizer.prototype, "speechRecognitionLanguage", {
        /**
         * Return the speech language used by the recognizer
         */
        get: function () {
            return this.privSpeechRecognitionLanguage;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConversationTranslatorRecognizer.prototype, "properties", {
        /**
         * Return the properties for the recognizer
         */
        get: function () {
            return this.privProperties;
        },
        enumerable: true,
        configurable: true
    });
    ConversationTranslatorRecognizer.prototype.isDisposed = function () {
        return this.privIsDisposed;
    };
    /**
     * Connect to the recognizer
     * @param token
     */
    ConversationTranslatorRecognizer.prototype.connect = function (token, cb, err) {
        try {
            Contracts_1.Contracts.throwIfDisposed(this.privIsDisposed);
            Contracts_1.Contracts.throwIfNullOrWhitespace(token, "token");
            this.privReco.conversationTranslatorToken = token;
            this.privReco.connectAsync(cb, err);
        }
        catch (error) {
            if (!!err) {
                if (error instanceof Error) {
                    var typedError = error;
                    err(typedError.name + ": " + typedError.message);
                }
                else {
                    err(error);
                }
            }
        }
    };
    /**
     * Disconnect from the recognizer
     */
    ConversationTranslatorRecognizer.prototype.disconnect = function (cb, err) {
        try {
            Contracts_1.Contracts.throwIfDisposed(this.privIsDisposed);
            this.privRoom = undefined;
            this.privReco.disconnectAsync(cb, err);
        }
        catch (error) {
            if (!!err) {
                if (error instanceof Error) {
                    var typedError = error;
                    err(typedError.name + ": " + typedError.message);
                }
                else {
                    err(error);
                }
            }
            // Destroy the recognizer.
            this.dispose(true);
        }
    };
    /**
     * Send the text message command to the websocket
     * @param conversationId
     * @param participantId
     * @param message
     */
    ConversationTranslatorRecognizer.prototype.sendMessageRequest = function (message, cb, err) {
        try {
            Contracts_1.Contracts.throwIfDisposed(this.privIsDisposed);
            Contracts_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId");
            Contracts_1.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId");
            Contracts_1.Contracts.throwIfNullOrWhitespace(message, "message");
            var command = {
                // tslint:disable-next-line: object-literal-shorthand
                participantId: this.privRoom.participantId,
                roomId: this.privRoom.roomId,
                text: message,
                type: ConversationTranslatorInterfaces_1.ConversationTranslatorMessageTypes.instantMessage
            };
            this.sendMessage(JSON.stringify(command), cb, err);
        }
        catch (error) {
            if (!!err) {
                if (error instanceof Error) {
                    var typedError = error;
                    err(typedError.name + ": " + typedError.message);
                }
                else {
                    err(error);
                }
            }
            // Destroy the recognizer.
            this.dispose(true);
        }
    };
    /**
     * Send the lock conversation command to the websocket
     * @param conversationId
     * @param participantId
     * @param isLocked
     */
    ConversationTranslatorRecognizer.prototype.sendLockRequest = function (isLocked, cb, err) {
        try {
            Contracts_1.Contracts.throwIfDisposed(this.privIsDisposed);
            Contracts_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId");
            Contracts_1.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId");
            Contracts_1.Contracts.throwIfNullOrUndefined(isLocked, "isLocked");
            var command = {
                command: ConversationTranslatorInterfaces_1.ConversationTranslatorCommandTypes.setLockState,
                // tslint:disable-next-line: object-literal-shorthand
                participantId: this.privRoom.participantId,
                roomid: this.privRoom.roomId,
                type: ConversationTranslatorInterfaces_1.ConversationTranslatorMessageTypes.participantCommand,
                value: isLocked
            };
            this.sendMessage(JSON.stringify(command), cb, err);
        }
        catch (error) {
            if (!!err) {
                if (error instanceof Error) {
                    var typedError = error;
                    err(typedError.name + ": " + typedError.message);
                }
                else {
                    err(error);
                }
            }
            // Destroy the recognizer.
            this.dispose(true);
        }
    };
    /**
     * Send the mute all participants command to the websocket
     * @param conversationId
     * @param participantId
     * @param isMuted
     */
    ConversationTranslatorRecognizer.prototype.sendMuteAllRequest = function (isMuted, cb, err) {
        try {
            Contracts_1.Contracts.throwIfDisposed(this.privIsDisposed);
            Contracts_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId");
            Contracts_1.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId");
            Contracts_1.Contracts.throwIfNullOrUndefined(isMuted, "isMuted");
            var command = {
                command: ConversationTranslatorInterfaces_1.ConversationTranslatorCommandTypes.setMuteAll,
                // tslint:disable-next-line: object-literal-shorthand
                participantId: this.privRoom.participantId,
                roomid: this.privRoom.roomId,
                type: ConversationTranslatorInterfaces_1.ConversationTranslatorMessageTypes.participantCommand,
                value: isMuted
            };
            this.sendMessage(JSON.stringify(command), cb, err);
        }
        catch (error) {
            if (!!err) {
                if (error instanceof Error) {
                    var typedError = error;
                    err(typedError.name + ": " + typedError.message);
                }
                else {
                    err(error);
                }
            }
            // Destroy the recognizer.
            this.dispose(true);
        }
    };
    /**
     * Send the mute participant command to the websocket
     * @param conversationId
     * @param participantId
     * @param isMuted
     */
    ConversationTranslatorRecognizer.prototype.sendMuteRequest = function (participantId, isMuted, cb, err) {
        try {
            Contracts_1.Contracts.throwIfDisposed(this.privIsDisposed);
            Contracts_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId");
            Contracts_1.Contracts.throwIfNullOrWhitespace(participantId, "participantId");
            Contracts_1.Contracts.throwIfNullOrUndefined(isMuted, "isMuted");
            var command = {
                command: ConversationTranslatorInterfaces_1.ConversationTranslatorCommandTypes.setMute,
                // tslint:disable-next-line: object-literal-shorthand
                participantId: participantId,
                roomid: this.privRoom.roomId,
                type: ConversationTranslatorInterfaces_1.ConversationTranslatorMessageTypes.participantCommand,
                value: isMuted
            };
            this.sendMessage(JSON.stringify(command), cb, err);
        }
        catch (error) {
            if (!!err) {
                if (error instanceof Error) {
                    var typedError = error;
                    err(typedError.name + ": " + typedError.message);
                }
                else {
                    err(error);
                }
            }
            // Destroy the recognizer.
            this.dispose(true);
        }
    };
    /**
     * Send the eject participant command to the websocket
     * @param conversationId
     * @param participantId
     */
    ConversationTranslatorRecognizer.prototype.sendEjectRequest = function (participantId, cb, err) {
        try {
            Contracts_1.Contracts.throwIfDisposed(this.privIsDisposed);
            Contracts_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId");
            Contracts_1.Contracts.throwIfNullOrWhitespace(participantId, "participantId");
            var command = {
                command: ConversationTranslatorInterfaces_1.ConversationTranslatorCommandTypes.ejectParticipant,
                // tslint:disable-next-line: object-literal-shorthand
                participantId: participantId,
                roomid: this.privRoom.roomId,
                type: ConversationTranslatorInterfaces_1.ConversationTranslatorMessageTypes.participantCommand,
            };
            this.sendMessage(JSON.stringify(command), cb, err);
            if (!!cb) {
                try {
                    cb();
                }
                catch (e) {
                    if (!!err) {
                        err(e);
                    }
                }
            }
        }
        catch (error) {
            if (!!err) {
                if (error instanceof Error) {
                    var typedError = error;
                    err(typedError.name + ": " + typedError.message);
                }
                else {
                    err(error);
                }
            }
            // Destroy the recognizer.
            this.dispose(true);
        }
    };
    /**
     * Send the mute participant command to the websocket
     * @param conversationId
     * @param participantId
     * @param isMuted
     */
    ConversationTranslatorRecognizer.prototype.sendChangeNicknameRequest = function (nickname, cb, err) {
        try {
            Contracts_1.Contracts.throwIfDisposed(this.privIsDisposed);
            Contracts_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId");
            Contracts_1.Contracts.throwIfNullOrWhitespace(nickname, "nickname");
            var command = {
                command: ConversationTranslatorInterfaces_1.ConversationTranslatorCommandTypes.changeNickname,
                nickname: nickname,
                // tslint:disable-next-line: object-literal-shorthand
                participantId: this.privRoom.participantId,
                roomid: this.privRoom.roomId,
                type: ConversationTranslatorInterfaces_1.ConversationTranslatorMessageTypes.participantCommand,
                value: nickname
            };
            this.sendMessage(JSON.stringify(command), cb, err);
        }
        catch (error) {
            if (!!err) {
                if (error instanceof Error) {
                    var typedError = error;
                    err(typedError.name + ": " + typedError.message);
                }
                else {
                    err(error);
                }
            }
            // Destroy the recognizer.
            this.dispose(true);
        }
    };
    /**
     * Close and dispose the recognizer
     */
    ConversationTranslatorRecognizer.prototype.close = function () {
        Contracts_1.Contracts.throwIfDisposed(this.privIsDisposed);
        this.dispose(true);
    };
    /**
     * Dispose the recognizer
     * @param disposing
     */
    ConversationTranslatorRecognizer.prototype.dispose = function (disposing) {
        if (this.privIsDisposed) {
            return;
        }
        if (disposing) {
            this.privIsDisposed = true;
            _super.prototype.dispose.call(this, disposing);
        }
    };
    /**
     * Create the config for the recognizer
     * @param speechConfig
     */
    ConversationTranslatorRecognizer.prototype.createRecognizerConfig = function (speechConfig) {
        return new Exports_1.RecognizerConfig(speechConfig, this.privProperties);
    };
    /**
     * Create the service recognizer.
     * The audio source is redundnant here but is required by the implementation.
     * @param authentication
     * @param connectionFactory
     * @param audioConfig
     * @param recognizerConfig
     */
    ConversationTranslatorRecognizer.prototype.createServiceRecognizer = function (authentication, connectionFactory, audioConfig, recognizerConfig) {
        var audioSource = audioConfig;
        return new ConversationServiceAdapter_1.ConversationServiceAdapter(authentication, connectionFactory, audioSource, recognizerConfig, this);
    };
    ConversationTranslatorRecognizer.prototype.sendMessage = function (msg, cb, err) {
        var withAsync = this.privReco;
        ConversationUtils_1.PromiseToEmptyCallback(withAsync.sendMessageAsync(msg), cb, err);
    };
    return ConversationTranslatorRecognizer;
}(Exports_2.Recognizer));
exports.ConversationTranslatorRecognizer = ConversationTranslatorRecognizer;

//# sourceMappingURL=ConversationTranslatorRecognizer.js.map
