{"version":3,"sources":["src/common.speech/Transcription/ConversationTranslatorRecognizer.ts"],"names":[],"mappings":"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","file":"ConversationTranslatorRecognizer.d.ts","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    IAuthentication,\r\n    IConnectionFactory,\r\n    RecognizerConfig,\r\n    ServiceRecognizerBase,\r\n    SpeechServiceConfig\r\n} from \"../../common.speech/Exports\";\r\nimport { AudioConfigImpl } from \"../../sdk/Audio/AudioConfig\";\r\nimport { Contracts } from \"../../sdk/Contracts\";\r\nimport { AudioConfig,\r\n    ConversationExpirationEventArgs,\r\n    ConversationParticipantsChangedEventArgs,\r\n    ConversationTranslationCanceledEventArgs,\r\n    PropertyCollection,\r\n    Recognizer,\r\n    SessionEventArgs,\r\n    SpeechTranslationConfig} from \"../../sdk/Exports\";\r\nimport { SpeechTranslationConfigImpl } from \"../../sdk/SpeechTranslationConfig\";\r\nimport { Callback } from \"../../sdk/Transcription/IConversation\";\r\nimport { ConversationConnectionFactory } from \"./ConversationConnectionFactory\";\r\nimport { ConversationServiceAdapter } from \"./ConversationServiceAdapter\";\r\nimport {\r\n    ConversationReceivedTranslationEventArgs,\r\n    LockRoomEventArgs,\r\n    MuteAllEventArgs,\r\n    ParticipantAttributeEventArgs,\r\n    ParticipantEventArgs,\r\n    ParticipantsListEventArgs } from \"./ConversationTranslatorEventArgs\";\r\nimport {\r\n    ConversationTranslatorCommandTypes,\r\n    ConversationTranslatorMessageTypes,\r\n    IChangeNicknameCommand,\r\n    IConversationTranslatorRecognizer,\r\n    IEjectParticipantCommand,\r\n    IInstantMessageCommand,\r\n    IInternalConversation,\r\n    ILockConversationCommand,\r\n    IMuteAllCommand,\r\n    IMuteCommand} from \"./ConversationTranslatorInterfaces\";\r\nimport { PromiseToEmptyCallback } from \"./ConversationUtils\";\r\n\r\n/**\r\n * Sends messages to the Conversation Translator websocket and listens for incoming events containing websocket messages.\r\n * Based off the recognizers in the SDK folder.\r\n */\r\nexport class ConversationTranslatorRecognizer extends Recognizer implements IConversationTranslatorRecognizer {\r\n\r\n    private privIsDisposed: boolean;\r\n    private privSpeechRecognitionLanguage: string;\r\n    private privRoom: IInternalConversation;\r\n\r\n    public constructor(speechConfig: SpeechTranslationConfig, audioConfig?: AudioConfig) {\r\n        const serviceConfigImpl = speechConfig as SpeechTranslationConfigImpl;\r\n        Contracts.throwIfNull(serviceConfigImpl, \"speechConfig\");\r\n\r\n        super(audioConfig, serviceConfigImpl.properties, new ConversationConnectionFactory());\r\n\r\n        this.privIsDisposed = false;\r\n        this.privProperties = serviceConfigImpl.properties.clone();\r\n\r\n    }\r\n\r\n    public canceled: (sender: IConversationTranslatorRecognizer, event: ConversationTranslationCanceledEventArgs) => void;\r\n    public conversationExpiration: (sender: IConversationTranslatorRecognizer, event: ConversationExpirationEventArgs) => void;\r\n    public lockRoomCommandReceived: (sender: IConversationTranslatorRecognizer, event: LockRoomEventArgs) => void;\r\n    public muteAllCommandReceived: (sender: IConversationTranslatorRecognizer, event: MuteAllEventArgs) => void;\r\n    public participantJoinCommandReceived: (sender: IConversationTranslatorRecognizer, event: ParticipantEventArgs) => void;\r\n    public participantLeaveCommandReceived: (sender: IConversationTranslatorRecognizer, event: ParticipantEventArgs) => void;\r\n    public participantUpdateCommandReceived: (sender: IConversationTranslatorRecognizer, event: ParticipantAttributeEventArgs) => void;\r\n    public connectionOpened: (sender: IConversationTranslatorRecognizer, event: SessionEventArgs) => void;\r\n    public connectionClosed: (sender: IConversationTranslatorRecognizer, event: SessionEventArgs) => void;\r\n    public translationReceived: (sender: IConversationTranslatorRecognizer, event: ConversationReceivedTranslationEventArgs) => void;\r\n    public participantsListReceived: (sender: IConversationTranslatorRecognizer, event: ParticipantsListEventArgs) => void;\r\n    public participantsChanged: (sender: IConversationTranslatorRecognizer, event: ConversationParticipantsChangedEventArgs) => void;\r\n\r\n    public set conversation(value: IInternalConversation) {\r\n        this.privRoom = value;\r\n    }\r\n\r\n    /**\r\n     * Return the speech language used by the recognizer\r\n     */\r\n    public get speechRecognitionLanguage(): string {\r\n        return this.privSpeechRecognitionLanguage;\r\n    }\r\n\r\n    /**\r\n     * Return the properties for the recognizer\r\n     */\r\n    public get properties(): PropertyCollection {\r\n        return this.privProperties;\r\n    }\r\n\r\n    public isDisposed(): boolean {\r\n        return this.privIsDisposed;\r\n    }\r\n\r\n    /**\r\n     * Connect to the recognizer\r\n     * @param token\r\n     */\r\n    public connect(token: string, cb?: () => void, err?: (e: string) => void): void {\r\n        try {\r\n            Contracts.throwIfDisposed(this.privIsDisposed);\r\n            Contracts.throwIfNullOrWhitespace(token, \"token\");\r\n            this.privReco.conversationTranslatorToken = token;\r\n            this.privReco.connectAsync(cb, err);\r\n        } catch (error) {\r\n            if (!!err) {\r\n                if (error instanceof Error) {\r\n                    const typedError: Error = error as Error;\r\n                    err(typedError.name + \": \" + typedError.message);\r\n                } else {\r\n                    err(error);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disconnect from the recognizer\r\n     */\r\n    public disconnect(cb?: () => void, err?: (e: string) => void): void {\r\n        try {\r\n            Contracts.throwIfDisposed(this.privIsDisposed);\r\n            this.privRoom = undefined;\r\n            this.privReco.disconnectAsync(cb, err);\r\n        } catch (error) {\r\n            if (!!err) {\r\n                if (error instanceof Error) {\r\n                    const typedError: Error = error as Error;\r\n                    err(typedError.name + \": \" + typedError.message);\r\n                } else {\r\n                    err(error);\r\n                }\r\n            }\r\n            // Destroy the recognizer.\r\n            this.dispose(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send the text message command to the websocket\r\n     * @param conversationId\r\n     * @param participantId\r\n     * @param message\r\n     */\r\n    public sendMessageRequest(message: string, cb?: () => void, err?: (e: string) => void): void {\r\n        try {\r\n            Contracts.throwIfDisposed(this.privIsDisposed);\r\n            Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\r\n            Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, \"participantId\");\r\n            Contracts.throwIfNullOrWhitespace(message, \"message\");\r\n\r\n            const command: IInstantMessageCommand = {\r\n                // tslint:disable-next-line: object-literal-shorthand\r\n                participantId: this.privRoom.participantId,\r\n                roomId: this.privRoom.roomId,\r\n                text: message,\r\n                type: ConversationTranslatorMessageTypes.instantMessage\r\n            };\r\n\r\n            this.sendMessage(JSON.stringify(command), cb, err);\r\n\r\n        } catch (error) {\r\n            if (!!err) {\r\n                if (error instanceof Error) {\r\n                    const typedError: Error = error as Error;\r\n                    err(typedError.name + \": \" + typedError.message);\r\n                } else {\r\n                    err(error);\r\n                }\r\n            }\r\n\r\n            // Destroy the recognizer.\r\n            this.dispose(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send the lock conversation command to the websocket\r\n     * @param conversationId\r\n     * @param participantId\r\n     * @param isLocked\r\n     */\r\n    public sendLockRequest(isLocked: boolean, cb?: () => void, err?: (e: string) => void): void {\r\n\r\n        try {\r\n            Contracts.throwIfDisposed(this.privIsDisposed);\r\n            Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\r\n            Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, \"participantId\");\r\n            Contracts.throwIfNullOrUndefined(isLocked, \"isLocked\");\r\n\r\n            const command: ILockConversationCommand = {\r\n                command: ConversationTranslatorCommandTypes.setLockState,\r\n                // tslint:disable-next-line: object-literal-shorthand\r\n                participantId: this.privRoom.participantId,\r\n                roomid: this.privRoom.roomId,\r\n                type: ConversationTranslatorMessageTypes.participantCommand,\r\n                value: isLocked\r\n            };\r\n\r\n            this.sendMessage(JSON.stringify(command), cb, err);\r\n        } catch (error) {\r\n            if (!!err) {\r\n                if (error instanceof Error) {\r\n                    const typedError: Error = error as Error;\r\n                    err(typedError.name + \": \" + typedError.message);\r\n                } else {\r\n                    err(error);\r\n                }\r\n            }\r\n\r\n            // Destroy the recognizer.\r\n            this.dispose(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send the mute all participants command to the websocket\r\n     * @param conversationId\r\n     * @param participantId\r\n     * @param isMuted\r\n     */\r\n    public sendMuteAllRequest(isMuted: boolean, cb?: () => void, err?: (e: string) => void): void {\r\n\r\n        try {\r\n            Contracts.throwIfDisposed(this.privIsDisposed);\r\n            Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\r\n            Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, \"participantId\");\r\n            Contracts.throwIfNullOrUndefined(isMuted, \"isMuted\");\r\n\r\n            const command: IMuteAllCommand = {\r\n                command: ConversationTranslatorCommandTypes.setMuteAll,\r\n                // tslint:disable-next-line: object-literal-shorthand\r\n                participantId: this.privRoom.participantId, // the id of the host\r\n                roomid: this.privRoom.roomId,\r\n                type: ConversationTranslatorMessageTypes.participantCommand,\r\n                value: isMuted\r\n            };\r\n\r\n            this.sendMessage(JSON.stringify(command), cb, err);\r\n        } catch (error) {\r\n            if (!!err) {\r\n                if (error instanceof Error) {\r\n                    const typedError: Error = error as Error;\r\n                    err(typedError.name + \": \" + typedError.message);\r\n                } else {\r\n                    err(error);\r\n                }\r\n            }\r\n\r\n            // Destroy the recognizer.\r\n            this.dispose(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send the mute participant command to the websocket\r\n     * @param conversationId\r\n     * @param participantId\r\n     * @param isMuted\r\n     */\r\n    public sendMuteRequest(participantId: string, isMuted: boolean, cb?: () => void, err?: (e: string) => void): void {\r\n\r\n        try {\r\n            Contracts.throwIfDisposed(this.privIsDisposed);\r\n            Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\r\n            Contracts.throwIfNullOrWhitespace(participantId, \"participantId\");\r\n            Contracts.throwIfNullOrUndefined(isMuted, \"isMuted\");\r\n\r\n            const command: IMuteCommand = {\r\n                command: ConversationTranslatorCommandTypes.setMute,\r\n                // tslint:disable-next-line: object-literal-shorthand\r\n                participantId: participantId, // the id of the participant\r\n                roomid: this.privRoom.roomId,\r\n                type: ConversationTranslatorMessageTypes.participantCommand,\r\n                value: isMuted\r\n            };\r\n\r\n            this.sendMessage(JSON.stringify(command), cb, err);\r\n        } catch (error) {\r\n            if (!!err) {\r\n                if (error instanceof Error) {\r\n                    const typedError: Error = error as Error;\r\n                    err(typedError.name + \": \" + typedError.message);\r\n                } else {\r\n                    err(error);\r\n                }\r\n            }\r\n\r\n            // Destroy the recognizer.\r\n            this.dispose(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send the eject participant command to the websocket\r\n     * @param conversationId\r\n     * @param participantId\r\n     */\r\n    public sendEjectRequest(participantId: string, cb?: () => void, err?: (e: string) => void): void {\r\n\r\n        try {\r\n            Contracts.throwIfDisposed(this.privIsDisposed);\r\n            Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\r\n            Contracts.throwIfNullOrWhitespace(participantId, \"participantId\");\r\n\r\n            const command: IEjectParticipantCommand = {\r\n                command: ConversationTranslatorCommandTypes.ejectParticipant,\r\n                // tslint:disable-next-line: object-literal-shorthand\r\n                participantId: participantId,\r\n                roomid: this.privRoom.roomId,\r\n                type: ConversationTranslatorMessageTypes.participantCommand,\r\n            };\r\n\r\n            this.sendMessage(JSON.stringify(command), cb, err);\r\n\r\n            if (!!cb) {\r\n                try {\r\n                    cb();\r\n                } catch (e) {\r\n                    if (!!err) {\r\n                        err(e);\r\n                    }\r\n                }\r\n            }\r\n\r\n        } catch (error) {\r\n            if (!!err) {\r\n                if (error instanceof Error) {\r\n                    const typedError: Error = error as Error;\r\n                    err(typedError.name + \": \" + typedError.message);\r\n                } else {\r\n                    err(error);\r\n                }\r\n            }\r\n\r\n            // Destroy the recognizer.\r\n            this.dispose(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send the mute participant command to the websocket\r\n     * @param conversationId\r\n     * @param participantId\r\n     * @param isMuted\r\n     */\r\n    public sendChangeNicknameRequest(nickname: string, cb?: () => void, err?: (e: string) => void): void {\r\n\r\n        try {\r\n            Contracts.throwIfDisposed(this.privIsDisposed);\r\n            Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\r\n            Contracts.throwIfNullOrWhitespace(nickname, \"nickname\");\r\n\r\n            const command: IChangeNicknameCommand = {\r\n                command: ConversationTranslatorCommandTypes.changeNickname,\r\n                nickname,\r\n                // tslint:disable-next-line: object-literal-shorthand\r\n                participantId: this.privRoom.participantId, // the id of the host\r\n                roomid: this.privRoom.roomId,\r\n                type: ConversationTranslatorMessageTypes.participantCommand,\r\n                value: nickname\r\n            };\r\n\r\n            this.sendMessage(JSON.stringify(command), cb, err);\r\n\r\n        } catch (error) {\r\n            if (!!err) {\r\n                if (error instanceof Error) {\r\n                    const typedError: Error = error as Error;\r\n                    err(typedError.name + \": \" + typedError.message);\r\n                } else {\r\n                    err(error);\r\n                }\r\n            }\r\n\r\n            // Destroy the recognizer.\r\n            this.dispose(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Close and dispose the recognizer\r\n     */\r\n    public close(): void {\r\n        Contracts.throwIfDisposed(this.privIsDisposed);\r\n        this.dispose(true);\r\n    }\r\n\r\n    /**\r\n     * Dispose the recognizer\r\n     * @param disposing\r\n     */\r\n    protected dispose(disposing: boolean): boolean {\r\n        if (this.privIsDisposed) {\r\n            return;\r\n        }\r\n        if (disposing) {\r\n            this.privIsDisposed = true;\r\n            super.dispose(disposing);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create the config for the recognizer\r\n     * @param speechConfig\r\n     */\r\n    protected createRecognizerConfig(speechConfig: SpeechServiceConfig): RecognizerConfig {\r\n        return new RecognizerConfig(speechConfig, this.privProperties);\r\n    }\r\n\r\n    /**\r\n     * Create the service recognizer.\r\n     * The audio source is redundnant here but is required by the implementation.\r\n     * @param authentication\r\n     * @param connectionFactory\r\n     * @param audioConfig\r\n     * @param recognizerConfig\r\n     */\r\n    protected createServiceRecognizer(\r\n        authentication: IAuthentication,\r\n        connectionFactory: IConnectionFactory,\r\n        audioConfig: AudioConfig,\r\n        recognizerConfig: RecognizerConfig): ServiceRecognizerBase {\r\n\r\n        const audioSource: AudioConfigImpl = audioConfig as AudioConfigImpl;\r\n\r\n        return new ConversationServiceAdapter(authentication, connectionFactory, audioSource, recognizerConfig, this);\r\n    }\r\n\r\n    private sendMessage(msg: string, cb?: Callback, err?: Callback): void {\r\n        const withAsync = this.privReco as ConversationServiceAdapter;\r\n        PromiseToEmptyCallback(withAsync.sendMessageAsync(msg), cb, err);\r\n    }\r\n\r\n}\r\n"]}