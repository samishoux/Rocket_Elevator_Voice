{"version":3,"sources":["src/common.speech/Transcription/ConversationServiceAdapter.ts"],"names":[],"mappings":"AAGA,OAAO,EAEH,iBAAiB,EAKjB,YAAY,EACZ,WAAW,EAEX,OAAO,EAGV,MAAM,sBAAsB,CAAC;AAE9B,OAAO,EACH,qBAAqB,EACrB,kBAAkB,EAQrB,MAAM,mBAAmB,CAAC;AAC3B,OAAO,EACO,eAAe,EAAE,kBAAkB,EAAE,gBAAgB,EAAE,qBAAqB,EACzF,MAAM,YAAY,CAAC;AAYpB,OAAO,EAAE,gCAAgC,EAAE,MAAM,oCAAoC,CAAC;AAYtF;;GAEG;AACH,qBAAa,0BAA2B,SAAQ,qBAAqB;IACjE,OAAO,CAAC,gCAAgC,CAAmC;IAC3E,OAAO,CAAC,iCAAiC,CAAqB;IAC9D,OAAO,CAAC,gCAAgC,CAAS;IACjD,OAAO,CAAC,8BAA8B,CAAkB;IACxD,OAAO,CAAC,8BAA8B,CAA6B;IACnE,OAAO,CAAC,2BAA2B,CAAuB;IAC1D,OAAO,CAAC,iCAAiC,CAAuB;IAChE,OAAO,CAAC,kBAAkB,CAAuB;IACjD,OAAO,CAAC,oBAAoB,CAAU;IACtC,OAAO,CAAC,0BAA0B,CAAc;IAChD,OAAO,CAAC,0BAA0B,CAAU;gBAGxC,cAAc,EAAE,eAAe,EAC/B,iBAAiB,EAAE,kBAAkB,EACrC,WAAW,EAAE,YAAY,EACzB,gBAAgB,EAAE,gBAAgB,EAClC,4BAA4B,EAAE,gCAAgC;IAiB3D,UAAU,IAAI,OAAO;IAIrB,OAAO,CAAC,MAAM,CAAC,EAAE,MAAM,GAAG,IAAI;IAS9B,WAAW,CAAC,OAAO,EAAE,MAAM,GAAG,IAAI;IAQlC,gBAAgB,wCA2BtB;IAED,SAAS,CAAC,cAAc,IAAI,IAAI;IAuBhC,SAAS,CAAC,2BAA2B,CACjC,iBAAiB,EAAE,iBAAiB,EACpC,eAAe,CAAC,EAAE,CAAC,CAAC,EAAE,GAAG,KAAK,IAAI,EAClC,aAAa,CAAC,EAAE,CAAC,CAAC,EAAE,MAAM,KAAK,IAAI,GAAG,OAAO;IAKjD,SAAS,CAAC,iBAAiB,CACvB,SAAS,EAAE,MAAM,EACjB,SAAS,EAAE,MAAM,EACjB,kBAAkB,EAAE,kBAAkB,EACtC,SAAS,EAAE,qBAAqB,EAChC,KAAK,EAAE,MAAM,GAAG,IAAI;IAoBxB,SAAS,CAAC,IAAI,YAEb;IAED;;;OAGG;IACH,SAAS,CAAC,uBAAuB,CAAC,cAAc,GAAE,OAAe,GAAG,OAAO,CAAC,WAAW,CAAC;IAiExF;;OAEG;IACH,OAAO,CAAC,kCAAkC,CAuUzC;IAED,OAAO,CAAC,gBAAgB;IAmBxB,OAAO,CAAC,gBAAgB;IAwBxB,OAAO,CAAC,eAAe;IAavB,OAAO,CAAC,2BAA2B,CAElC;CAEJ","file":"ConversationServiceAdapter.d.ts","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    ConnectionEvent,\r\n    ConnectionMessage,\r\n    ConnectionOpenResponse,\r\n    ConnectionState,\r\n    createNoDashGuid,\r\n    Deferred,\r\n    IAudioSource,\r\n    IConnection,\r\n    MessageType,\r\n    Promise,\r\n    PromiseHelper,\r\n    PromiseResult\r\n} from \"../../common/Exports\";\r\nimport { Sink } from \"../../common/Promise\";\r\nimport {\r\n    CancellationErrorCode,\r\n    CancellationReason,\r\n    ConversationExpirationEventArgs,\r\n    ConversationTranslationCanceledEventArgs,\r\n    ConversationTranslationResult,\r\n    PropertyId,\r\n    SessionEventArgs,\r\n    SpeechRecognitionResult,\r\n    Translations\r\n} from \"../../sdk/Exports\";\r\nimport {\r\n    AuthInfo, IAuthentication, IConnectionFactory, RecognizerConfig, ServiceRecognizerBase\r\n} from \"../Exports\";\r\nimport { ConversationConnectionMessage } from \"./ConversationConnectionMessage\";\r\nimport { ConversationRequestSession } from \"./ConversationRequestSession\";\r\nimport {\r\n    ConversationReceivedTranslationEventArgs,\r\n    LockRoomEventArgs,\r\n    MuteAllEventArgs,\r\n    ParticipantAttributeEventArgs,\r\n    ParticipantEventArgs,\r\n    ParticipantsListEventArgs\r\n} from \"./ConversationTranslatorEventArgs\";\r\nimport { ConversationTranslatorCommandTypes, ConversationTranslatorMessageTypes, IInternalParticipant } from \"./ConversationTranslatorInterfaces\";\r\nimport { ConversationTranslatorRecognizer } from \"./ConversationTranslatorRecognizer\";\r\nimport {\r\n    CommandResponsePayload,\r\n    IParticipantPayloadResponse,\r\n    IParticipantsListPayloadResponse,\r\n    ITranslationResponsePayload,\r\n    ParticipantPayloadResponse,\r\n    ParticipantsListPayloadResponse,\r\n    SpeechResponsePayload,\r\n    TextResponsePayload\r\n} from \"./ServiceMessages/Exports\";\r\n\r\n/***\r\n * The service adapter handles sending and receiving messages to the Conversation Translator websocket.\r\n */\r\nexport class ConversationServiceAdapter extends ServiceRecognizerBase {\r\n    private privConversationServiceConnector: ConversationTranslatorRecognizer;\r\n    private privConversationConnectionFactory: IConnectionFactory;\r\n    private privConversationAuthFetchEventId: string;\r\n    private privConversationAuthentication: IAuthentication;\r\n    private privConversationRequestSession: ConversationRequestSession;\r\n    private privConnectionConfigPromise: Promise<IConnection>;\r\n    private privConversationConnectionPromise: Promise<IConnection>;\r\n    private privConnectionLoop: Promise<IConnection>;\r\n    private terminateMessageLoop: boolean;\r\n    private privLastPartialUtteranceId: string = \"\";\r\n    private privConversationIsDisposed: boolean;\r\n\r\n    public constructor(\r\n        authentication: IAuthentication,\r\n        connectionFactory: IConnectionFactory,\r\n        audioSource: IAudioSource,\r\n        recognizerConfig: RecognizerConfig,\r\n        conversationServiceConnector: ConversationTranslatorRecognizer) {\r\n\r\n        super(authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector);\r\n\r\n        this.privConversationServiceConnector = conversationServiceConnector;\r\n        this.privConversationAuthentication = authentication;\r\n        this.receiveMessageOverride = this.receiveConversationMessageOverride;\r\n        this.recognizeOverride = this.noOp;\r\n        this.connectImplOverride = this.conversationConnectImpl;\r\n        this.configConnectionOverride = this.configConnection;\r\n        this.fetchConnectionOverride = this.fetchConversationConnection;\r\n        this.disconnectOverride = this.privDisconnect;\r\n        this.privConversationRequestSession = new ConversationRequestSession(createNoDashGuid());\r\n        this.privConversationConnectionFactory = connectionFactory;\r\n        this.privConversationIsDisposed = false;\r\n    }\r\n\r\n    public isDisposed(): boolean {\r\n        return this.privConversationIsDisposed;\r\n    }\r\n\r\n    public dispose(reason?: string): void {\r\n        this.privConversationIsDisposed = true;\r\n        if (this.privConnectionConfigPromise) {\r\n            this.privConnectionConfigPromise.onSuccessContinueWith((connection: IConnection) => {\r\n                connection.dispose(reason);\r\n            });\r\n        }\r\n    }\r\n\r\n    public sendMessage(message: string): void {\r\n        this.fetchConversationConnection().onSuccessContinueWith((connection: IConnection) => {\r\n            connection.send(new ConversationConnectionMessage(\r\n                MessageType.Text,\r\n                message));\r\n        });\r\n    }\r\n\r\n    public sendMessageAsync = (message: string): Promise<boolean> => {\r\n        const sink: Sink<boolean> = new Sink<boolean>();\r\n\r\n        this.fetchConversationConnection().continueWith((antecedent: PromiseResult<IConnection>): void => {\r\n            try {\r\n                if (antecedent.isError) {\r\n                    sink.reject(antecedent.error);\r\n                } else {\r\n                    antecedent.result.send(new ConversationConnectionMessage(MessageType.Text, message))\r\n                        .continueWith((innerAntecedent: PromiseResult<boolean>): void => {\r\n                            try {\r\n                                if (innerAntecedent.isError) {\r\n                                    sink.reject(innerAntecedent.error);\r\n                                } else {\r\n                                    sink.resolve(innerAntecedent.result);\r\n                                }\r\n                            } catch (e) {\r\n                                sink.reject(`Unhandled inner error: ${e}`);\r\n                            }\r\n                        });\r\n                }\r\n            } catch (e) {\r\n                sink.reject(`Unhandled error: ${e}`);\r\n            }\r\n        });\r\n\r\n        return new Promise<boolean>(sink);\r\n    }\r\n\r\n    protected privDisconnect(): void {\r\n        if (this.terminateMessageLoop) {\r\n            return;\r\n        }\r\n        this.cancelRecognition(this.privConversationRequestSession.sessionId,\r\n            this.privConversationRequestSession.requestId,\r\n            CancellationReason.Error,\r\n            CancellationErrorCode.NoError,\r\n            \"Disconnecting\");\r\n\r\n        this.terminateMessageLoop = true;\r\n        if (this.privConversationConnectionPromise.result().isCompleted) {\r\n            if (!this.privConversationConnectionPromise.result().isError) {\r\n                this.privConversationConnectionPromise.result().result.dispose();\r\n                this.privConversationConnectionPromise = null;\r\n            }\r\n        } else {\r\n            this.privConversationConnectionPromise.onSuccessContinueWith((connection: IConnection) => {\r\n                connection.dispose();\r\n            });\r\n        }\r\n    }\r\n\r\n    protected processTypeSpecificMessages(\r\n        connectionMessage: ConnectionMessage,\r\n        successCallback?: (e: any) => void,\r\n        errorCallBack?: (e: string) => void): boolean {\r\n        return true;\r\n    }\r\n\r\n    // Cancels recognition.\r\n    protected cancelRecognition(\r\n        sessionId: string,\r\n        requestId: string,\r\n        cancellationReason: CancellationReason,\r\n        errorCode: CancellationErrorCode,\r\n        error: string): void {\r\n\r\n        this.terminateMessageLoop = true;\r\n\r\n        const cancelEvent: ConversationTranslationCanceledEventArgs = new ConversationTranslationCanceledEventArgs(\r\n            cancellationReason,\r\n            error,\r\n            errorCode,\r\n            undefined,\r\n            sessionId);\r\n\r\n        try {\r\n            if (!!this.privConversationServiceConnector.canceled) {\r\n                this.privConversationServiceConnector.canceled(this.privConversationServiceConnector, cancelEvent);\r\n            }\r\n        } catch {\r\n            // continue on error\r\n        }\r\n    }\r\n\r\n    protected noOp = (): any => {\r\n        // operation not supported\r\n    }\r\n\r\n    /**\r\n     * Establishes a websocket connection to the end point.\r\n     * @param isUnAuthorized\r\n     */\r\n    protected conversationConnectImpl(isUnAuthorized: boolean = false): Promise<IConnection> {\r\n\r\n        if (this.privConversationConnectionPromise) {\r\n            if (this.privConversationConnectionPromise.result().isCompleted &&\r\n                (this.privConversationConnectionPromise.result().isError\r\n                    || this.privConversationConnectionPromise.result().result.state() === ConnectionState.Disconnected)) {\r\n                this.privConnectionId = null;\r\n                this.privConversationConnectionPromise = null;\r\n                this.terminateMessageLoop = true;\r\n                return this.conversationConnectImpl();\r\n            } else {\r\n                return this.privConversationConnectionPromise;\r\n            }\r\n        }\r\n\r\n        this.privConversationAuthFetchEventId = createNoDashGuid();\r\n\r\n        // keep the connectionId for reconnect events\r\n        if (this.privConnectionId === undefined) {\r\n            this.privConnectionId = createNoDashGuid();\r\n        }\r\n\r\n        this.privConversationRequestSession.onPreConnectionStart(this.privConversationAuthFetchEventId, this.privConnectionId);\r\n\r\n        const authPromise = isUnAuthorized ? this.privConversationAuthentication.fetchOnExpiry(this.privConversationAuthFetchEventId) : this.privConversationAuthentication.fetch(this.privConversationAuthFetchEventId);\r\n\r\n        this.privConversationConnectionPromise = authPromise\r\n            .continueWithPromise((result: PromiseResult<AuthInfo>) => {\r\n                if (result.isError) {\r\n                    this.privConversationRequestSession.onAuthCompleted(true, result.error);\r\n                    throw new Error(result.error);\r\n                } else {\r\n                    this.privConversationRequestSession.onAuthCompleted(false);\r\n                }\r\n\r\n                const connection: IConnection = this.privConversationConnectionFactory.create(this.privRecognizerConfig, result.result, this.privConnectionId);\r\n\r\n                // Attach to the underlying event. No need to hold onto the detach pointers as in the event the connection goes away,\r\n                // it'll stop sending events.\r\n                connection.events.attach((event: ConnectionEvent) => {\r\n                    this.connectionEvents.onEvent(event);\r\n                });\r\n\r\n                return connection.open().onSuccessContinueWithPromise((response: ConnectionOpenResponse): Promise<IConnection> => {\r\n                    if (response.statusCode === 200) {\r\n                        this.privConversationRequestSession.onPreConnectionStart(this.privConversationAuthFetchEventId, this.privConnectionId);\r\n                        this.privConversationRequestSession.onConnectionEstablishCompleted(response.statusCode);\r\n                        const sessionStartEventArgs: SessionEventArgs = new SessionEventArgs(this.privConversationRequestSession.sessionId);\r\n                        if (!!this.privConversationServiceConnector.connectionOpened) {\r\n                            this.privConversationServiceConnector.connectionOpened(this.privConversationServiceConnector, sessionStartEventArgs);\r\n                        }\r\n                        return PromiseHelper.fromResult<IConnection>(connection);\r\n                    } else if (response.statusCode === 403 && !isUnAuthorized) {\r\n                        return this.conversationConnectImpl(true);\r\n                    } else {\r\n                        this.privConversationRequestSession.onConnectionEstablishCompleted(response.statusCode, response.reason);\r\n                        return PromiseHelper.fromError<IConnection>(`Unable to contact server. StatusCode: ${response.statusCode}, ${this.privRecognizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${response.reason}`);\r\n                    }\r\n                });\r\n            });\r\n\r\n        this.privConnectionLoop = this.startMessageLoop();\r\n        return this.privConversationConnectionPromise;\r\n    }\r\n\r\n    /**\r\n     * Process incoming websocket messages\r\n     */\r\n    private receiveConversationMessageOverride = (\r\n        successCallback?: (e: any) => void,\r\n        errorCallBack?: (e: string) => void\r\n    ): Promise<IConnection> => {\r\n\r\n        // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages\r\n        const communicationCustodian: Deferred<IConnection> = new Deferred<IConnection>();\r\n\r\n        this.fetchConversationConnection().on((connection: IConnection): Promise<IConnection> => {\r\n            return connection.read().onSuccessContinueWithPromise((message: ConversationConnectionMessage): Promise<IConnection> => {\r\n                const isDisposed: boolean = this.isDisposed();\r\n                const terminateMessageLoop = (!this.isDisposed() && this.terminateMessageLoop);\r\n                const sessionId: string = this.privConversationRequestSession.sessionId;\r\n                let sendFinal: boolean = false;\r\n                if (isDisposed || terminateMessageLoop) {\r\n                    // We're done.\r\n                    communicationCustodian.resolve(undefined);\r\n                    return PromiseHelper.fromResult<IConnection>(undefined);\r\n                }\r\n\r\n                if (!message) {\r\n                    return this.receiveConversationMessageOverride();\r\n                }\r\n\r\n                try {\r\n                    switch (message.conversationMessageType.toLowerCase()) {\r\n                        case \"info\":\r\n                        case \"participant_command\":\r\n                        case \"command\":\r\n                            const commandPayload: CommandResponsePayload = CommandResponsePayload.fromJSON(message.textBody);\r\n                            switch (commandPayload.command.toLowerCase()) {\r\n\r\n                                /**\r\n                                 * 'ParticpantList' is the first message sent to the user after the websocket connection has opened.\r\n                                 * The consuming client must wait for this message to arrive\r\n                                 * before starting to send their own data.\r\n                                 */\r\n                                case \"participantlist\":\r\n\r\n                                    const participantsPayload: IParticipantsListPayloadResponse = ParticipantsListPayloadResponse.fromJSON(message.textBody);\r\n\r\n                                    const participantsResult: IInternalParticipant[] = participantsPayload.participants.map((p: IParticipantPayloadResponse) => {\r\n                                        const participant: IInternalParticipant = {\r\n                                            avatar: p.avatar,\r\n                                            displayName: p.nickname,\r\n                                            id: p.participantId,\r\n                                            isHost: p.ishost,\r\n                                            isMuted: p.ismuted,\r\n                                            isUsingTts: p.usetts,\r\n                                            preferredLanguage: p.locale\r\n                                        };\r\n                                        return participant;\r\n                                    });\r\n\r\n                                    if (!!this.privConversationServiceConnector.participantsListReceived) {\r\n                                        this.privConversationServiceConnector.participantsListReceived(this.privConversationServiceConnector,\r\n                                            new ParticipantsListEventArgs(participantsPayload.roomid, participantsPayload.token,\r\n                                                participantsPayload.translateTo, participantsPayload.profanityFilter,\r\n                                                participantsPayload.roomProfanityFilter, participantsPayload.roomLocked,\r\n                                                participantsPayload.muteAll, participantsResult, sessionId));\r\n                                    }\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'SetTranslateToLanguages' represents the list of languages being used in the Conversation by all users(?).\r\n                                 * This is sent at the start of the Conversation\r\n                                 */\r\n                                case \"settranslatetolanguages\":\r\n\r\n                                    if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                        this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                            new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                                ConversationTranslatorCommandTypes.setTranslateToLanguages,\r\n                                                commandPayload.value, sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'SetProfanityFiltering' lets the client set the level of profanity filtering.\r\n                                 * If sent by the participant the setting will effect only their own profanity level.\r\n                                 * If sent by the host, the setting will effect all participants including the host.\r\n                                 * Note: the profanity filters differ from Speech Service (?): 'marked', 'raw', 'removed', 'tagged'\r\n                                 */\r\n                                case \"setprofanityfiltering\":\r\n\r\n                                    if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                        this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                            new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                                ConversationTranslatorCommandTypes.setProfanityFiltering,\r\n                                                commandPayload.value, sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'SetMute' is sent if the participant has been muted by the host.\r\n                                 * Check the 'participantId' to determine if the current user has been muted.\r\n                                 */\r\n                                case \"setmute\":\r\n\r\n                                    if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                        this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                            new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                                ConversationTranslatorCommandTypes.setMute,\r\n                                                commandPayload.value, sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'SetMuteAll' is sent if the Conversation has been muted by the host.\r\n                                 */\r\n                                case \"setmuteall\":\r\n\r\n                                    if (!!this.privConversationServiceConnector.muteAllCommandReceived) {\r\n                                        this.privConversationServiceConnector.muteAllCommandReceived(this.privConversationServiceConnector,\r\n                                            new MuteAllEventArgs(commandPayload.value as boolean, sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'RoomExpirationWarning' is sent towards the end of the Conversation session to give a timeout warning.\r\n                                 */\r\n                                case \"roomexpirationwarning\":\r\n\r\n                                    if (!!this.privConversationServiceConnector.conversationExpiration) {\r\n                                        this.privConversationServiceConnector.conversationExpiration(this.privConversationServiceConnector,\r\n                                            new ConversationExpirationEventArgs(commandPayload.value as number, this.privConversationRequestSession.sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'SetUseTts' is sent as a confirmation if the user requests TTS to be turned on or off.\r\n                                 */\r\n                                case \"setusetts\":\r\n\r\n                                    if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                        this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                            new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                                ConversationTranslatorCommandTypes.setUseTTS,\r\n                                                commandPayload.value, sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'SetLockState' is set if the host has locked or unlocked the Conversation.\r\n                                 */\r\n                                case \"setlockstate\":\r\n\r\n                                    if (!!this.privConversationServiceConnector.lockRoomCommandReceived) {\r\n                                        this.privConversationServiceConnector.lockRoomCommandReceived(this.privConversationServiceConnector,\r\n                                            new LockRoomEventArgs(commandPayload.value as boolean, sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'ChangeNickname' is received if a user changes their display name.\r\n                                 * Any cached particpiants list should be updated to reflect the display name.\r\n                                 */\r\n                                case \"changenickname\":\r\n\r\n                                    if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                        this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                            new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                                ConversationTranslatorCommandTypes.changeNickname,\r\n                                                commandPayload.nickname, sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'JoinSession' is sent when a user joins the Conversation.\r\n                                 */\r\n                                case \"joinsession\":\r\n\r\n                                    const joinParticipantPayload: ParticipantPayloadResponse = ParticipantPayloadResponse.fromJSON(message.textBody);\r\n\r\n                                    const joiningParticipant: IInternalParticipant = {\r\n                                        avatar: joinParticipantPayload.avatar,\r\n                                        displayName: joinParticipantPayload.nickname,\r\n                                        id: joinParticipantPayload.participantId,\r\n                                        isHost: joinParticipantPayload.ishost,\r\n                                        isMuted: joinParticipantPayload.ismuted,\r\n                                        isUsingTts: joinParticipantPayload.usetts,\r\n                                        preferredLanguage: joinParticipantPayload.locale,\r\n                                    };\r\n\r\n                                    if (!!this.privConversationServiceConnector.participantJoinCommandReceived) {\r\n                                        this.privConversationServiceConnector.participantJoinCommandReceived(this.privConversationServiceConnector,\r\n                                            new ParticipantEventArgs(\r\n                                                joiningParticipant,\r\n                                                sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'LeaveSession' is sent when a user leaves the Conversation'.\r\n                                 */\r\n                                case \"leavesession\":\r\n\r\n                                    const leavingParticipant: IInternalParticipant = {\r\n                                        id: commandPayload.participantId\r\n                                    };\r\n\r\n                                    if (!!this.privConversationServiceConnector.participantLeaveCommandReceived) {\r\n                                        this.privConversationServiceConnector.participantLeaveCommandReceived(this.privConversationServiceConnector,\r\n                                            new ParticipantEventArgs(leavingParticipant, sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'DisconnectSession' is sent when a user is disconnected from the session (e.g. network problem).\r\n                                 * Check the 'ParticipantId' to check whether the message is for the current user.\r\n                                 */\r\n                                case \"disconnectsession\":\r\n\r\n                                    const disconnectParticipant: IInternalParticipant = {\r\n                                        id: commandPayload.participantId\r\n                                    };\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * Message not recognized.\r\n                                 */\r\n                                default:\r\n                                    break;\r\n                            }\r\n                            break;\r\n\r\n                        /**\r\n                         * 'partial' (or 'hypothesis') represents a unfinalized speech message.\r\n                         */\r\n                        case \"partial\":\r\n\r\n                        /**\r\n                         * 'final' (or 'phrase') represents a finalized speech message.\r\n                         */\r\n                        case \"final\":\r\n\r\n                            const speechPayload: SpeechResponsePayload = SpeechResponsePayload.fromJSON(message.textBody);\r\n\r\n                            const speechResult: ConversationTranslationResult = new ConversationTranslationResult(speechPayload.participantId,\r\n                                this.getTranslations(speechPayload.translations),\r\n                                speechPayload.language,\r\n                                undefined,\r\n                                undefined,\r\n                                speechPayload.recognition,\r\n                                undefined,\r\n                                undefined,\r\n                                message.textBody,\r\n                                undefined);\r\n\r\n                            if (speechPayload.isFinal) {\r\n                                // check the length, sometimes empty finals are returned\r\n                                if (speechResult.text !== undefined && speechResult.text.length > 0) {\r\n                                    sendFinal = true;\r\n                                } else if (speechPayload.id === this.privLastPartialUtteranceId) {\r\n                                    // send final as normal. We had a non-empty partial for this same utterance\r\n                                    // so sending the empty final is important\r\n                                    sendFinal = true;\r\n                                } else {\r\n                                    // suppress unneeded final\r\n                                }\r\n\r\n                                if (sendFinal) {\r\n                                    if (!!this.privConversationServiceConnector.translationReceived) {\r\n                                        this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector,\r\n                                            new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.final, speechResult, sessionId));\r\n                                    }\r\n                                }\r\n                            } else if (speechResult.text !== undefined) {\r\n                                this.privLastPartialUtteranceId = speechPayload.id;\r\n                                if (!!this.privConversationServiceConnector.translationReceived) {\r\n                                    this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector,\r\n                                        new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.partial, speechResult, sessionId));\r\n                                }\r\n                            }\r\n\r\n                            break;\r\n\r\n                        /**\r\n                         * \"translated_message\" is a text message or instant message (IM).\r\n                         */\r\n                        case \"translated_message\":\r\n\r\n                            const textPayload: TextResponsePayload = TextResponsePayload.fromJSON(message.textBody);\r\n\r\n                            const textResult: ConversationTranslationResult = new ConversationTranslationResult(textPayload.participantId,\r\n                                this.getTranslations(textPayload.translations),\r\n                                textPayload.language,\r\n                                undefined,\r\n                                undefined,\r\n                                textPayload.originalText,\r\n                                undefined,\r\n                                undefined,\r\n                                undefined,\r\n                                message.textBody,\r\n                                undefined);\r\n\r\n                            if (!!this.privConversationServiceConnector.translationReceived) {\r\n                                this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector,\r\n                                    new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.instantMessage, textResult, sessionId));\r\n                            }\r\n                            break;\r\n\r\n                        default:\r\n                            // ignore any unsupported message types\r\n                            break;\r\n                    }\r\n                } catch (e) {\r\n                    // continue\r\n                }\r\n                return this.receiveConversationMessageOverride();\r\n            });\r\n        }, (error: string) => {\r\n            this.terminateMessageLoop = true;\r\n        });\r\n\r\n        return communicationCustodian.promise();\r\n    }\r\n\r\n    private startMessageLoop(): Promise<IConnection> {\r\n\r\n        this.terminateMessageLoop = false;\r\n\r\n        const messageRetrievalPromise = this.receiveConversationMessageOverride();\r\n\r\n        return messageRetrievalPromise.on((r: IConnection) => {\r\n            return true;\r\n        }, (error: string) => {\r\n            this.cancelRecognition(\r\n                this.privRequestSession ? this.privRequestSession.sessionId : \"\",\r\n                this.privRequestSession ? this.privRequestSession.requestId : \"\",\r\n                CancellationReason.Error,\r\n                CancellationErrorCode.RuntimeError,\r\n                error);\r\n        });\r\n    }\r\n\r\n    // Takes an established websocket connection to the endpoint\r\n    private configConnection(): Promise<IConnection> {\r\n        if (this.privConnectionConfigPromise) {\r\n            if (this.privConnectionConfigPromise.result().isCompleted &&\r\n                (this.privConnectionConfigPromise.result().isError\r\n                    || this.privConnectionConfigPromise.result().result.state() === ConnectionState.Disconnected)) {\r\n\r\n                this.privConnectionConfigPromise = null;\r\n                return this.configConnection();\r\n            } else {\r\n                return this.privConnectionConfigPromise;\r\n            }\r\n        }\r\n\r\n        if (this.terminateMessageLoop) {\r\n            return PromiseHelper.fromResult<IConnection>(undefined);\r\n        }\r\n\r\n        this.privConnectionConfigPromise = this.conversationConnectImpl()\r\n            .onSuccessContinueWith((connection: IConnection): any => {\r\n                return connection;\r\n            });\r\n        return this.privConnectionConfigPromise;\r\n    }\r\n\r\n    private getTranslations(serviceResultTranslations: ITranslationResponsePayload[]): Translations {\r\n        let translations: Translations;\r\n\r\n        if (undefined !== serviceResultTranslations) {\r\n            translations = new Translations();\r\n            for (const translation of serviceResultTranslations) {\r\n                translations.set(translation.lang, translation.translation);\r\n            }\r\n        }\r\n\r\n        return translations;\r\n    }\r\n\r\n    private fetchConversationConnection = (): Promise<IConnection> => {\r\n        return this.configConnection();\r\n    }\r\n\r\n}\r\n"]}