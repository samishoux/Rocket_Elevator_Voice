import { IAuthentication, IConnectionFactory, RecognizerConfig, ServiceRecognizerBase, SpeechServiceConfig } from "../../common.speech/Exports";
import { AudioConfig, ConversationExpirationEventArgs, ConversationParticipantsChangedEventArgs, ConversationTranslationCanceledEventArgs, PropertyCollection, Recognizer, SessionEventArgs, SpeechTranslationConfig } from "../../sdk/Exports";
import { ConversationReceivedTranslationEventArgs, LockRoomEventArgs, MuteAllEventArgs, ParticipantAttributeEventArgs, ParticipantEventArgs, ParticipantsListEventArgs } from "./ConversationTranslatorEventArgs";
import { IConversationTranslatorRecognizer, IInternalConversation } from "./ConversationTranslatorInterfaces";
/**
 * Sends messages to the Conversation Translator websocket and listens for incoming events containing websocket messages.
 * Based off the recognizers in the SDK folder.
 */
export declare class ConversationTranslatorRecognizer extends Recognizer implements IConversationTranslatorRecognizer {
    private privIsDisposed;
    private privSpeechRecognitionLanguage;
    private privRoom;
    constructor(speechConfig: SpeechTranslationConfig, audioConfig?: AudioConfig);
    canceled: (sender: IConversationTranslatorRecognizer, event: ConversationTranslationCanceledEventArgs) => void;
    conversationExpiration: (sender: IConversationTranslatorRecognizer, event: ConversationExpirationEventArgs) => void;
    lockRoomCommandReceived: (sender: IConversationTranslatorRecognizer, event: LockRoomEventArgs) => void;
    muteAllCommandReceived: (sender: IConversationTranslatorRecognizer, event: MuteAllEventArgs) => void;
    participantJoinCommandReceived: (sender: IConversationTranslatorRecognizer, event: ParticipantEventArgs) => void;
    participantLeaveCommandReceived: (sender: IConversationTranslatorRecognizer, event: ParticipantEventArgs) => void;
    participantUpdateCommandReceived: (sender: IConversationTranslatorRecognizer, event: ParticipantAttributeEventArgs) => void;
    connectionOpened: (sender: IConversationTranslatorRecognizer, event: SessionEventArgs) => void;
    connectionClosed: (sender: IConversationTranslatorRecognizer, event: SessionEventArgs) => void;
    translationReceived: (sender: IConversationTranslatorRecognizer, event: ConversationReceivedTranslationEventArgs) => void;
    participantsListReceived: (sender: IConversationTranslatorRecognizer, event: ParticipantsListEventArgs) => void;
    participantsChanged: (sender: IConversationTranslatorRecognizer, event: ConversationParticipantsChangedEventArgs) => void;
    set conversation(value: IInternalConversation);
    /**
     * Return the speech language used by the recognizer
     */
    get speechRecognitionLanguage(): string;
    /**
     * Return the properties for the recognizer
     */
    get properties(): PropertyCollection;
    isDisposed(): boolean;
    /**
     * Connect to the recognizer
     * @param token
     */
    connect(token: string, cb?: () => void, err?: (e: string) => void): void;
    /**
     * Disconnect from the recognizer
     */
    disconnect(cb?: () => void, err?: (e: string) => void): void;
    /**
     * Send the text message command to the websocket
     * @param conversationId
     * @param participantId
     * @param message
     */
    sendMessageRequest(message: string, cb?: () => void, err?: (e: string) => void): void;
    /**
     * Send the lock conversation command to the websocket
     * @param conversationId
     * @param participantId
     * @param isLocked
     */
    sendLockRequest(isLocked: boolean, cb?: () => void, err?: (e: string) => void): void;
    /**
     * Send the mute all participants command to the websocket
     * @param conversationId
     * @param participantId
     * @param isMuted
     */
    sendMuteAllRequest(isMuted: boolean, cb?: () => void, err?: (e: string) => void): void;
    /**
     * Send the mute participant command to the websocket
     * @param conversationId
     * @param participantId
     * @param isMuted
     */
    sendMuteRequest(participantId: string, isMuted: boolean, cb?: () => void, err?: (e: string) => void): void;
    /**
     * Send the eject participant command to the websocket
     * @param conversationId
     * @param participantId
     */
    sendEjectRequest(participantId: string, cb?: () => void, err?: (e: string) => void): void;
    /**
     * Send the mute participant command to the websocket
     * @param conversationId
     * @param participantId
     * @param isMuted
     */
    sendChangeNicknameRequest(nickname: string, cb?: () => void, err?: (e: string) => void): void;
    /**
     * Close and dispose the recognizer
     */
    close(): void;
    /**
     * Dispose the recognizer
     * @param disposing
     */
    protected dispose(disposing: boolean): boolean;
    /**
     * Create the config for the recognizer
     * @param speechConfig
     */
    protected createRecognizerConfig(speechConfig: SpeechServiceConfig): RecognizerConfig;
    /**
     * Create the service recognizer.
     * The audio source is redundnant here but is required by the implementation.
     * @param authentication
     * @param connectionFactory
     * @param audioConfig
     * @param recognizerConfig
     */
    protected createServiceRecognizer(authentication: IAuthentication, connectionFactory: IConnectionFactory, audioConfig: AudioConfig, recognizerConfig: RecognizerConfig): ServiceRecognizerBase;
    private sendMessage;
}
