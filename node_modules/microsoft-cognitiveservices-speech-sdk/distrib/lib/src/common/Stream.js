"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
var Error_1 = require("./Error");
var Guid_1 = require("./Guid");
var Queue_1 = require("./Queue");
var Stream = /** @class */ (function () {
    function Stream(streamId) {
        var _this = this;
        this.privIsWriteEnded = false;
        this.privIsReadEnded = false;
        this.read = function () {
            if (_this.privIsReadEnded) {
                throw new Error_1.InvalidOperationError("Stream read has already finished");
            }
            return _this.privReaderQueue
                .dequeue()
                .onSuccessContinueWith(function (streamChunk) {
                if (streamChunk === undefined || streamChunk.isEnd) {
                    _this.privReaderQueue.dispose("End of stream reached");
                }
                return streamChunk;
            });
        };
        this.readEnded = function () {
            if (!_this.privIsReadEnded) {
                _this.privIsReadEnded = true;
                _this.privReaderQueue = new Queue_1.Queue();
            }
        };
        this.throwIfClosed = function () {
            if (_this.privIsWriteEnded) {
                throw new Error_1.InvalidOperationError("Stream closed");
            }
        };
        this.privId = streamId ? streamId : Guid_1.createNoDashGuid();
        this.privReaderQueue = new Queue_1.Queue();
    }
    Object.defineProperty(Stream.prototype, "isClosed", {
        get: function () {
            return this.privIsWriteEnded;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stream.prototype, "isReadEnded", {
        get: function () {
            return this.privIsReadEnded;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stream.prototype, "id", {
        get: function () {
            return this.privId;
        },
        enumerable: true,
        configurable: true
    });
    Stream.prototype.close = function () {
        if (!this.privIsWriteEnded) {
            this.writeStreamChunk({
                buffer: null,
                isEnd: true,
                timeReceived: Date.now(),
            });
            this.privIsWriteEnded = true;
        }
    };
    Stream.prototype.writeStreamChunk = function (streamChunk) {
        this.throwIfClosed();
        if (!this.privReaderQueue.isDisposed()) {
            try {
                this.privReaderQueue.enqueue(streamChunk);
            }
            catch (e) {
                // Do nothing
            }
        }
    };
    return Stream;
}());
exports.Stream = Stream;

//# sourceMappingURL=Stream.js.map
