"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
var Exports_1 = require("../../common.speech/Exports");
var Exports_2 = require("../../common/Exports");
var AudioOutputFormat_1 = require("./AudioOutputFormat");
var AudioOutputStream_1 = require("./AudioOutputStream");
var MediaDurationPlaceholderSeconds = 60 * 30;
var AudioFormatToMimeType = (_a = {},
    _a[AudioOutputFormat_1.AudioFormatTag.PCM] = "audio/wav",
    _a[AudioOutputFormat_1.AudioFormatTag.MP3] = "audio/mpeg",
    _a[AudioOutputFormat_1.AudioFormatTag.Opus] = "audio/ogg",
    _a);
/**
 * Represents the speaker playback audio destination, which only works in browser.
 * Note: the SDK will try to use <a href="https://www.w3.org/TR/media-source/">Media Source Extensions</a> to play audio.
 * Mp3 format has better supports on Microsoft Edge, Chrome and Safari (desktop), so, it's better to specify mp3 format for playback.
 * @class SpeakerAudioDestination
 * Updated in version 1.12.1
 */
var SpeakerAudioDestination = /** @class */ (function () {
    function SpeakerAudioDestination(audioDestinationId) {
        this.privPlaybackStarted = false;
        this.privAppendingToBuffer = false;
        this.privMediaSourceOpened = false;
        this.privBytesReceived = 0;
        this.privId = audioDestinationId ? audioDestinationId : Exports_2.createNoDashGuid();
        this.privIsPaused = false;
        this.privIsClosed = false;
    }
    SpeakerAudioDestination.prototype.id = function () {
        return this.privId;
    };
    SpeakerAudioDestination.prototype.write = function (buffer) {
        if (this.privAudioBuffer !== undefined) {
            this.privAudioBuffer.push(buffer);
            this.updateSourceBuffer();
        }
        else if (this.privAudioOutputStream !== undefined) {
            this.privAudioOutputStream.write(buffer);
            this.privBytesReceived += buffer.byteLength;
        }
    };
    SpeakerAudioDestination.prototype.close = function () {
        this.privIsClosed = true;
        if (this.privSourceBuffer !== undefined) {
            this.handleSourceBufferUpdateEnd();
        }
        else if (this.privAudioOutputStream !== undefined) {
            var receivedAudio = new ArrayBuffer(this.privBytesReceived);
            this.privAudioOutputStream.read(receivedAudio);
            if (this.privFormat.hasHeader) {
                receivedAudio = Exports_1.SynthesisAdapterBase.addHeader(receivedAudio, this.privFormat);
            }
            var audioBlob = new Blob([receivedAudio], { type: AudioFormatToMimeType[this.privFormat.formatTag] });
            this.privAudio.src = window.URL.createObjectURL(audioBlob);
            this.notifyPlayback();
        }
    };
    Object.defineProperty(SpeakerAudioDestination.prototype, "format", {
        set: function (format) {
            var _this = this;
            if (typeof (AudioContext) !== "undefined" || typeof (window.webkitAudioContext) !== "undefined") {
                this.privFormat = format;
                var mimeType_1 = AudioFormatToMimeType[this.privFormat.formatTag];
                if (mimeType_1 === undefined) {
                    // tslint:disable-next-line:no-console
                    console.warn("Unknown mimeType for format " + AudioOutputFormat_1.AudioFormatTag[this.privFormat.formatTag] + ".");
                }
                else if (typeof (MediaSource) !== "undefined" && MediaSource.isTypeSupported(mimeType_1)) {
                    this.privAudio = new Audio();
                    this.privAudioBuffer = [];
                    this.privMediaSource = new MediaSource();
                    this.privAudio.src = URL.createObjectURL(this.privMediaSource);
                    this.privAudio.load();
                    this.privMediaSource.onsourceopen = function (event) {
                        _this.privMediaSourceOpened = true;
                        _this.privMediaSource.duration = MediaDurationPlaceholderSeconds;
                        _this.privSourceBuffer = _this.privMediaSource.addSourceBuffer(mimeType_1);
                        _this.privSourceBuffer.onupdate = function (_) {
                            _this.updateSourceBuffer();
                        };
                        _this.privSourceBuffer.onupdateend = function (_) {
                            _this.handleSourceBufferUpdateEnd();
                        };
                        _this.privSourceBuffer.onupdatestart = function (_) {
                            _this.privAppendingToBuffer = false;
                        };
                    };
                    this.updateSourceBuffer();
                }
                else {
                    // tslint:disable-next-line:no-console
                    console.warn("Format " + AudioOutputFormat_1.AudioFormatTag[this.privFormat.formatTag] + " could not be played by MSE, streaming playback is not enabled.");
                    this.privAudioOutputStream = new AudioOutputStream_1.PullAudioOutputStreamImpl();
                    this.privAudioOutputStream.format = this.privFormat;
                    this.privAudio = new Audio();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpeakerAudioDestination.prototype, "isClosed", {
        get: function () {
            return this.privIsClosed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpeakerAudioDestination.prototype, "currentTime", {
        get: function () {
            if (this.privAudio !== undefined) {
                return this.privAudio.currentTime;
            }
            return -1;
        },
        enumerable: true,
        configurable: true
    });
    SpeakerAudioDestination.prototype.pause = function () {
        if (!this.privIsPaused && this.privAudio !== undefined) {
            this.privAudio.pause();
            this.privIsPaused = true;
        }
    };
    SpeakerAudioDestination.prototype.resume = function () {
        if (this.privIsPaused && this.privAudio !== undefined) {
            this.privAudio.play();
            this.privIsPaused = false;
        }
    };
    Object.defineProperty(SpeakerAudioDestination.prototype, "internalAudio", {
        get: function () {
            return this.privAudio;
        },
        enumerable: true,
        configurable: true
    });
    SpeakerAudioDestination.prototype.updateSourceBuffer = function () {
        if (this.privAudioBuffer !== undefined && (this.privAudioBuffer.length > 0) && this.sourceBufferAvailable()) {
            this.privAppendingToBuffer = true;
            var binary = this.privAudioBuffer.shift();
            try {
                this.privSourceBuffer.appendBuffer(binary);
            }
            catch (error) {
                this.privAudioBuffer.unshift(binary);
                // tslint:disable-next-line:no-console
                console.log("buffer filled, pausing addition of binaries until space is made");
                return;
            }
            this.notifyPlayback();
        }
        else if (this.canEndStream()) {
            this.handleSourceBufferUpdateEnd();
        }
    };
    SpeakerAudioDestination.prototype.handleSourceBufferUpdateEnd = function () {
        if (this.canEndStream() && this.sourceBufferAvailable()) {
            this.privMediaSource.endOfStream();
            this.notifyPlayback();
        }
    };
    SpeakerAudioDestination.prototype.notifyPlayback = function () {
        var _this = this;
        if (!this.privPlaybackStarted && this.privAudio !== undefined) {
            this.privAudio.onended = function () {
                if (!!_this.onAudioEnd) {
                    _this.onAudioEnd(_this);
                }
            };
            if (!this.privIsPaused) {
                this.privAudio.play();
            }
            this.privPlaybackStarted = true;
        }
    };
    SpeakerAudioDestination.prototype.canEndStream = function () {
        return (this.isClosed && this.privSourceBuffer !== undefined && (this.privAudioBuffer.length === 0)
            && this.privMediaSourceOpened && !this.privAppendingToBuffer && this.privMediaSource.readyState === "open");
    };
    SpeakerAudioDestination.prototype.sourceBufferAvailable = function () {
        return (this.privSourceBuffer !== undefined && !this.privSourceBuffer.updating);
    };
    return SpeakerAudioDestination;
}());
exports.SpeakerAudioDestination = SpeakerAudioDestination;

//# sourceMappingURL=SpeakerAudioDestination.js.map
